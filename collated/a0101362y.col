//@author: a0101362y



	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Date.cpp
	 */

#include "Date.h"

//-----CONSTRUCTORS----------------------------------------------------------------------------

/* 
	Purpose: Constructs an empty date object.
	Pre-conditions: N/A
	Post-conditions: Date object is constructed with all values initialised to 0. (empty date) 
*/
Date::Date(){
	_day = 0;
	_month = 0;
	_year = 0;
}

/* 
	Purpose: Constructs an empty date object given specified values.
	Pre-conditions: All values should be integers.
	Post-conditions: Date object is constructed with values initialised as specified. 
*/
Date::Date(int day, int month, int year){
	_day = day;
	_month = month;
	_year = year;
}

//-----CHECK METHODS---------------------------------------------------------------------------

/* 
	Purpose: Checks if date value is empty i.e. 0/0/0. 
	Pre-condition: Date value has been initialised.
	Post-condition: Returns true if date is empty (i.e. 0/0/0) and false otherwise.
*/
bool Date::isEmptyDate(){
	return (_day == 0 && _month == 0 && _year == 0);
}

/*
	Purpose: Checks if dates are equal.
	Pre-condition: Day/month/year values are integers.
	Post-condition: Returns true if dates are of the same value and false if otherwise.
*/
bool Date::isSameDate(Date checkDate){
	return (_year == checkDate._year && _month == checkDate._month && _day == checkDate._day);
}

/* 
	Purpose: Checks if checkDate is strictly after 'this' date. 
	Pre-condition: Day/month/year values are integers.
	Post-condition: Returns true if checkDate is after 'this' date and false otherwise. 
*/
bool Date::isLaterDate(Date checkDate){
	if (_year > checkDate._year){
		return false;
	}else if ((_year == checkDate._year) && (_month > checkDate._month)){
		return  false; 
	}else if ((_month == checkDate._month) && (_day > checkDate._day)){
		return false;
	}else if (_day == checkDate._day){
		return false;
	}
	return true;
}

/* 
	Purpose: Checks if date value exists and is valid. 
	Pre-condition: Date value has been initialised.
	Post-condition: Returns true if date is valid and false otherwise. 
*/
bool Date::isValidDate(){
	return (isValidDay() && isValidMonth() && isValidYear());
}

/* 
	Purpose: Checks if day value of year exists and is valid. 
	Pre-condition: Day value has been initialised.
	Post-condition: Returns true if day value of date is valid and false otherwise. 
*/
bool Date::isValidDay(){
	return (_day >= 1 && _day <= 31);
}

/* 
	Purpose: Checks if month value of date exists and is valid. 
	Pre-condition: Month value has been initialised.
	Post-condition: Returns true if month value of date is valid and false otherwise. 
*/
bool Date::isValidMonth(){
	return (_month >= 1 && _month <= 12);
}

/* 
	Purpose: Checks if year value of date is valid. 
	Pre-condition: Year value has been initialised.
	Post-condition: Returns true if year value of date is valid and false otherwise. 
*/
bool Date::isValidYear(){
	return (_year > 0);
}
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Date.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Date.h
	 */

#pragma once

class Date{ 
public:
	int _day;
	int _month;
	int _year;

//-----CONSTRUCTORS----------------------------------------------------------------------------

	//Default constructor (initialises all values to zero by default)
	Date();
	
	//Constructor with parameters
	Date(int, int, int);

//-----CHECK METHODS---------------------------------------------------------------------------

	//Checks if date value is empty i.e. 0/0/0
	bool isEmptyDate();

	//Checks if dates are equal
	bool isSameDate(Date);

	//Checks if checkDate is after 'this' date
	bool isLaterDate(Date);

	//Checks if date value is valid
	bool isValidDate();

	//Checks if day value of date is valid
	bool isValidDay();

	//Checks if month value of date is valid
	bool isValidMonth();

	//Checks if year value of date is valid
	bool isValidYear();
};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Date.h





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Parse.cpp
	 */

#include "Parse.h" 

//-----CONSTANT STRINGS------------------------------------------------------------------------

//KEYWORDS
const std::string Parse::KEYWORD_LOCATION = "at";
const std::string Parse::KEYWORD_STARTING = "from";
const std::string Parse::KEYWORD_ENDING = "to";
const std::string Parse::KEYWORD_DEADLINE = "by";
const std::string Parse::KEYWORD_HOURS = "hrs";
const std::string Parse::KEYWORD_BLOCK = "blockoff";
const std::string Parse::KEYWORD_BLOCK_BRACKETS = "(blockoff)";

//MISC
const std::string Parse::EMPTY_STRING = "";
const std::string Parse::SINGLE_SPACE = " ";
const std::string Parse::DATE_SEPARATOR = "/";
const std::string Parse::SYMBOL_DASH = "-";
const std::string Parse::SYMBOL_COLLON = ":";

//DAY KEYWORDS
const std::string Parse::DAY_KEYWORD_TODAY = "today";
const std::string Parse::DAY_KEYWORD_TOMORROW = "tomorrow";
const std::string Parse::DAY_KEYWORD_TMR = "tmr";
const std::string Parse::DAY_KEYWORD_MONDAY = "monday";
const std::string Parse::DAY_KEYWORD_MON = "mon";
const std::string Parse::DAY_KEYWORD_TUESDAY = "tuesday";
const std::string Parse::DAY_KEYWORD_TUES = "tues";
const std::string Parse::DAY_KEYWORD_TUE = "tue";
const std::string Parse::DAY_KEYWORD_WEDNESDAY = "wednesday";
const std::string Parse::DAY_KEYWORD_WED = "wed";
const std::string Parse::DAY_KEYWORD_THURSDAY = "thursday";
const std::string Parse::DAY_KEYWORD_THURS = "thurs";
const std::string Parse::DAY_KEYWORD_THUR = "thur";
const std::string Parse::DAY_KEYWORD_THU = "thu";
const std::string Parse::DAY_KEYWORD_FRIDAY = "friday";
const std::string Parse::DAY_KEYWORD_FRI = "fri";
const std::string Parse::DAY_KEYWORD_SATURDAY = "saturday";
const std::string Parse::DAY_KEYWORD_SAT = "sat";
const std::string Parse::DAY_KEYWORD_SUNDAY = "sunday";
const std::string Parse::DAY_KEYWORD_SUN = "sun";

//-----EXCEPTION FEEDBACK MESSAGES-------------------------------------------------------------

const std::string Parse::EXCEPTION_NO_START_DATE = "Missing start date";
const std::string Parse::EXCEPTION_NO_END_DATE = "Missing end date";
const std::string Parse::EXCEPTION_NO_DEADLINE_DATE = "Missing deadline date";
const std::string Parse::EXCEPTION_DATE_NO_YEAR = "Missing year input";
const std::string Parse::EXCEPTION_DATE_NO_MONTH = "Missing month input";
const std::string Parse::EXCEPTION_DATE_NO_DAY = "Missing day input";
const std::string Parse::EXCEPTION_INVALID_YEAR_INPUT = "Invalid year input: value out of range";
const std::string Parse::EXCEPTION_INVALID_MONTH_INPUT = "Invalid month input: value out of range";
const std::string Parse::EXCEPTION_INVALID_DAY_INPUT = "Invalid day input: value out of range";
const std::string Parse::EXCEPTION_INVALID_TIME_INPUT = "Invalid time input";
const std::string Parse::EXCEPTION_INVALID_YEAR_FORMAT = "Invalid year input format";
const std::string Parse::EXCEPTION_INVALID_MONTH_FORMAT = "Invalid month input format";
const std::string Parse::EXCEPTION_INVALID_DAY_FORMAT = "Invalid day input format";
const std::string Parse::EXCEPTION_INVALID_TIME_FORMAT = "Invalid time input format";
const std::string Parse::EXCEPTION_NOBLOCK_MULTIPLE_DATES = "Task should only indicate one start/end/deadline";
const std::string Parse::EXCEPTION_NOBLOCK_MULTIPLE_TYPES = "Task should indicate either only a start date or deadline date";
const std::string Parse::EXCEPTION_MISSING_START_TIME = "No starting time to match ending time";
const std::string Parse::EXCEPTION_MISSING_END_TIME = "No ending time to match starting time";
const std::string Parse::EXCEPTION_END_BEFORE_START_DATE = "End date occurs before start date";
const std::string Parse::EXCEPTION_START_END_SAME = "Start and end dates/times are the same";
const std::string Parse::EXCEPTION_END_BEFORE_START_TIME = "End time occurs before start time";

//-----CONSTANT INTEGERS-----------------------------------------------------------------------

const int Parse::EMPTY_TIME = -1;

//-----PROCESSING METHODS----------------------------------------------------------------------

/*
	Purpose: Takes task string from user input and processes it into its various Task variables.
	Pre-conditions: Default values ("" for string, empty values for date & time, false for block) have been initialised for parameters.
	Post-conditions: Parameters are updated by reference based on task string.
*/
void Parse::processTaskStringFromUI(std::string taskString, std::string & action, std::string & location, std::vector<Date> & startingDate, std::vector<int> & startingTime, std::vector<Date> & endingDate, std::vector<int> & endingTime, std::vector<Date> & deadlineDate, std::vector<int> & deadlineTime, bool & block, std::vector<std::string> & dateVector){
	std::istringstream userInputTask(taskString);
	std::string word;
	std::vector<std::string> taskDetails;

	while (userInputTask >> word){
		taskDetails.push_back(word);
	}

	std::string keyword = EMPTY_STRING;
	bool prevIsDate = false;

	for (unsigned int i = 0; i < taskDetails.size(); i++){ 
		if (isKeyword(taskDetails[i])){
			keyword = convertToLowercase(taskDetails[i]);
			if (keyword == KEYWORD_BLOCK){
				block = true;
			}
		}else if (keyword == EMPTY_STRING){
			if (action != EMPTY_STRING){
				action += SINGLE_SPACE;
			}
			action += taskDetails[i];
		}else if (keyword == KEYWORD_LOCATION){
			if (location != EMPTY_STRING){
				location += SINGLE_SPACE;
			}
			location += taskDetails[i];
		}else if (keyword == KEYWORD_STARTING){
			if (taskDetails[i].find(DATE_SEPARATOR) != std::string::npos){
				startingDate.push_back(convertToDate(taskDetails[i]));
				endingDate.push_back(Date());
				startingTime.push_back(EMPTY_TIME);
				endingTime.push_back(EMPTY_TIME);
				prevIsDate = true;
			}else if (isDayKeyword(taskDetails[i])){
				startingDate.push_back(convertToDate(changeDayToDate(taskDetails[i], dateVector)));
				endingDate.push_back(Date()); 
				startingTime.push_back(EMPTY_TIME);
				endingTime.push_back(EMPTY_TIME);
				prevIsDate = true;
			}else if (!prevIsDate){
				throw std::runtime_error(EXCEPTION_NO_START_DATE);
			}else if (!startingTime.empty()){
				startingTime[startingTime.size()-1] = convertToTime(taskDetails[i]);
				prevIsDate = false;
			}
		}else if (keyword == KEYWORD_ENDING){
			if (taskDetails[i].find(DATE_SEPARATOR) != std::string::npos){
				if (!endingDate.empty()){
					endingDate[endingDate.size()-1] = convertToDate(taskDetails[i]);
				}else{
					endingDate.push_back(convertToDate(taskDetails[i]));
				}
				prevIsDate = true;
			}else if (isDayKeyword(taskDetails[i])){
				if(!endingDate.empty()){
					endingDate[endingDate.size()-1] = convertToDate(changeDayToDate(taskDetails[i], dateVector));
				}else{
					endingDate.push_back(convertToDate(changeDayToDate(taskDetails[i], dateVector)));
				}
				prevIsDate = true;
			}else if (!prevIsDate){
					throw std::runtime_error(EXCEPTION_NO_END_DATE);
			}else if (!endingTime.empty()){
					endingTime[endingTime.size()-1] = convertToTime(taskDetails[i]);
					prevIsDate = false;
			}	
		}else if (keyword == KEYWORD_DEADLINE){
			if (taskDetails[i].find(DATE_SEPARATOR) != std::string::npos){
				deadlineDate.push_back(convertToDate(taskDetails[i]));
				deadlineTime.push_back(EMPTY_TIME);
				prevIsDate = true;
			}else if (isDayKeyword(taskDetails[i])){
				deadlineDate.push_back(convertToDate(changeDayToDate(taskDetails[i], dateVector)));
				deadlineTime.push_back(EMPTY_TIME);
				prevIsDate = true;
			}else if (!prevIsDate){
					throw std::runtime_error(EXCEPTION_NO_DEADLINE_DATE);
			}else if (!deadlineTime.empty()){
					deadlineTime[deadlineTime.size()-1] = convertToTime(taskDetails[i]);
					prevIsDate = false;
			}
		}
	}

	if (deadlineDate.empty()){
		deadlineDate.push_back(Date());
	}
	if (deadlineTime.empty()){
		deadlineTime.push_back(EMPTY_TIME);
	}
	if (startingDate.empty()){
		startingDate.push_back(Date());
	}
	if (startingTime.empty()){
		startingTime.push_back(EMPTY_TIME);
	}
	if (endingDate.empty()){
		endingDate.push_back(Date());
	}
	if (endingTime.empty()){
		endingTime.push_back(EMPTY_TIME);
	}
	
	assert(startingDate.size() == startingTime.size());
	assert(endingDate.size() == endingTime.size());
	assert(startingDate.size() == endingDate.size());
	assert(startingTime.size() == endingTime.size());
	assert(deadlineDate.size() == deadlineTime.size());

	try{
		//Multiple date/time inputs although not a block
		if (!block && (startingDate.size() > 1 || endingDate.size() > 1 || deadlineDate.size() > 1)){
			throw (std::runtime_error(EXCEPTION_NOBLOCK_MULTIPLE_DATES));
		}
		//Both starting/ending date/time input and deadline date/time input for a single task
		if (!block && ((!startingDate[0].isEmptyDate() && !deadlineDate[0].isEmptyDate()) || (!endingDate[0].isEmptyDate() && !deadlineDate[0].isEmptyDate()))){
			throw (std::runtime_error(EXCEPTION_NOBLOCK_MULTIPLE_TYPES));
		}
		//Start time is given without end time and vice versa
		for (unsigned int i = 0; i < startingDate.size(); i++){
			if (!startingDate[i].isEmptyDate() && !endingDate[i].isEmptyDate() && startingTime[i] == EMPTY_TIME && endingTime[i] != EMPTY_TIME){
				throw (std::runtime_error(EXCEPTION_MISSING_START_TIME));
			}
			if (!startingDate[i].isEmptyDate() && !endingDate[i].isEmptyDate() && startingTime[i] != EMPTY_TIME && endingTime[i] == EMPTY_TIME){
				throw (std::runtime_error(EXCEPTION_MISSING_END_TIME));
			}
		}
		for (unsigned int i = 0; i < startingDate.size(); i++){
			if (!startingDate[i].isEmptyDate() && !endingDate[i].isEmptyDate() && !startingDate[i].isLaterDate(endingDate[i])){
				if (startingDate[i].isSameDate(endingDate[i])){
					if (!startingDate[i].isEmptyDate() && !endingDate[i].isEmptyDate() && !isLaterTime(startingTime[i], endingTime[i])){
						if (isSameTime(startingTime[i], endingTime[i])){
							throw std::runtime_error(EXCEPTION_START_END_SAME);
						}else{ 
							throw std::runtime_error(EXCEPTION_END_BEFORE_START_TIME);
						}
					}
				}else{
					throw (std::runtime_error(EXCEPTION_END_BEFORE_START_DATE));
				}
			}
		}
	}catch (...){
		throw;
	}
		
	return;
}

/*
	Purpose: Takes task string from file storage and processes it into its various Task variables.
	Pre-conditions: Default values ("" for string, empty values for date & time, false for block) have been initialised for parameters.
	Post-conditions: Parameters are updated by reference based on task string. 
*/
void Parse::processTaskStringFromFile(std::string taskString, std::string & action, std::string & location, std::vector<Date> & startingDate, std::vector<int> & startingTime, std::vector<Date> & endingDate, std::vector<int> & endingTime, std::vector<Date> & deadlineDate, std::vector<int> & deadlineTime, bool & block){
	std::istringstream fileTask(taskString);
	std::string word;
	std::vector<std::string> taskDetails;

	while (fileTask >> word){
		taskDetails.push_back(word);
	}
	
	if (taskDetails[0] == KEYWORD_DEADLINE){	//Deadline task 
		unsigned int i = 1;
		while (i < taskDetails.size() && taskDetails[i] != KEYWORD_HOURS && taskDetails[i] != SYMBOL_COLLON){
			if (taskDetails[i].find(DATE_SEPARATOR) != std::string::npos){
				deadlineDate.push_back(convertToDate(taskDetails[i]));
			}else{
				deadlineTime.push_back(convertToTime(taskDetails[i]));
			}
			i++;
		}
		if (taskDetails[i] == KEYWORD_HOURS){
			i++;
		}
		if (taskDetails[i] == SYMBOL_COLLON){
			i++;
		}
		while (i < taskDetails.size() && taskDetails[i] != KEYWORD_LOCATION && taskDetails[i] != KEYWORD_BLOCK_BRACKETS){
			if (action != EMPTY_STRING){
				action += SINGLE_SPACE;
			}
			action += taskDetails[i];
			i++;
		}
		if (i < taskDetails.size() && taskDetails[i] == KEYWORD_LOCATION){
			i++;
		}
		while (i < taskDetails.size() && taskDetails[i] != KEYWORD_BLOCK_BRACKETS){
			if (location != EMPTY_STRING){
				location += SINGLE_SPACE;
			}
			location += taskDetails[i];
			i++;
		}
		if (i < taskDetails.size() && taskDetails[i] == KEYWORD_BLOCK_BRACKETS){
			block = true;
		} 
	}else if (taskDetails[0].find(DATE_SEPARATOR) != std::string::npos){		//Activity task 
		unsigned int i = 0;
		while (i < taskDetails.size() && taskDetails[i] != KEYWORD_HOURS && taskDetails[i] != SYMBOL_COLLON && taskDetails[i] != SYMBOL_DASH){
			if (taskDetails[i].find(DATE_SEPARATOR) != std::string::npos){
				startingDate.push_back(convertToDate(taskDetails[i]));
			}else{
				startingTime.push_back(convertToTime(taskDetails[i]));
			}
			i++;
		}
		if (taskDetails[i] == KEYWORD_HOURS){
			i++;
		}
		if (taskDetails[i] == SYMBOL_DASH){
			i++;
		}
		while (i < taskDetails.size() && taskDetails[i] != KEYWORD_HOURS && taskDetails[i] != SYMBOL_COLLON){ 
			if (taskDetails[i].find(DATE_SEPARATOR) != std::string::npos){
				endingDate.push_back(convertToDate(taskDetails[i]));
			}else{
				endingTime.push_back(convertToTime(taskDetails[i]));
			}
			i++;
		}
		if (taskDetails[i] == KEYWORD_HOURS){
			i++;
		}
		if (taskDetails[i] == SYMBOL_COLLON){
			i++;
		}
		while (i < taskDetails.size() && taskDetails[i] != KEYWORD_LOCATION && taskDetails[i] != KEYWORD_BLOCK_BRACKETS){
			if (action != EMPTY_STRING){
				action += SINGLE_SPACE;
			}
			action += taskDetails[i];
			i++;
		}
		if (i < taskDetails.size() && taskDetails[i] == KEYWORD_LOCATION){
			i++;
		}
		while (i < taskDetails.size() && taskDetails[i] != KEYWORD_BLOCK_BRACKETS){
			if (location != EMPTY_STRING){
				location += SINGLE_SPACE;
			}
			location += taskDetails[i];
			i++;
		}
		if (i < taskDetails.size() && taskDetails[i] == KEYWORD_BLOCK_BRACKETS){
			block = true;
		}
	}else{	//Floating task 
		unsigned int i = 0;
		while (i < taskDetails.size() && taskDetails[i] != KEYWORD_LOCATION){
			if (action != EMPTY_STRING){
				action += SINGLE_SPACE;
			}
			action += taskDetails[i];
			i++;
		}
		if (i < taskDetails.size() && taskDetails[i] == KEYWORD_LOCATION){
			i++;
		}
		while (i < taskDetails.size()){
			if (location != EMPTY_STRING){
				location += SINGLE_SPACE;
			}
			location += taskDetails[i];
			i++;
		}
	}

	if (deadlineDate.empty()){
		deadlineDate.push_back(Date());
	}
	if (deadlineTime.empty()){
		deadlineTime.push_back(EMPTY_TIME);
	}
	if (startingDate.empty()){
		startingDate.push_back(Date());
	}
	if (startingTime.empty()){
		startingTime.push_back(EMPTY_TIME);
	}
	if (endingDate.empty()){
		endingDate.push_back(Date());
	}
	if (endingTime.empty()){
		endingTime.push_back(EMPTY_TIME);
	}

	return;
}

//-----CONVERSION METHODS----------------------------------------------------------------------

/*
	Purpose: Takes a date in string type and converts it into Date type.
	Pre-conditions: Date string is in the correct format 'day/month/year'.
	Post-conditions: Returns date with correct day/month/year values.
*/ 
Date Parse::convertToDate(std::string dateString){
	Date date; 

	size_t posFirstDateSeparator = dateString.find(DATE_SEPARATOR);
	size_t posSecondDateSeparator = dateString.find(DATE_SEPARATOR, posFirstDateSeparator+1);

	std::string dayString = dateString.substr(0, posFirstDateSeparator-0); 
	std::string monthString = dateString.substr(posFirstDateSeparator+1, posSecondDateSeparator-posFirstDateSeparator-1);
	std::string yearString = dateString.substr(posSecondDateSeparator+1);

	try {
		if (yearString.empty()){
			throw (std::runtime_error(EXCEPTION_DATE_NO_YEAR));		
		}else if (monthString.empty()){
			throw (std::runtime_error(EXCEPTION_DATE_NO_MONTH));	
		}else if (dayString.empty()){
			throw (std::runtime_error(EXCEPTION_DATE_NO_DAY));		 
		}else if (!yearString.empty() && !isValidYearFormat(yearString)){
			throw (std::runtime_error(EXCEPTION_INVALID_YEAR_FORMAT));	
		}else if (!monthString.empty() && !isValidMonthFormat(monthString)){
			throw (std::runtime_error(EXCEPTION_INVALID_MONTH_FORMAT));	
		}else if (!dayString.empty() && !isValidDayFormat(dayString)){
			throw (std::runtime_error(EXCEPTION_INVALID_DAY_FORMAT));	
		}
	}catch (...) {
		throw;
	}

	std::istringstream dayInput(dayString);
	std::istringstream monthInput(monthString);
	std::istringstream yearInput(yearString);

	dayInput >> date._day;
	monthInput >> date._month;
	yearInput >> date._year;
	
	if (date._year < 100){
		date._year += 2000;
	}
	
	try {
		if (!date.isValidDate()){
			if (!date.isValidDay()){
				throw std::runtime_error(EXCEPTION_INVALID_DAY_INPUT);		
			}else if (!date.isValidMonth()){
				throw std::runtime_error(EXCEPTION_INVALID_MONTH_INPUT);	
			}else if (!date.isValidYear()){
				throw std::runtime_error(EXCEPTION_INVALID_YEAR_INPUT);		
			}
		}
	}catch (...) {
		throw;
	}

	return date;
}

/*
	Purpose: Takes a time in string type and converts it into integer type.
	Pre-conditions: Time string is made up of 4 numerical digits.
	Post-conditions: Returns time as an integer type value. 
*/
int Parse::convertToTime(std::string timeString){
	int time;

	try {
		if (!isValidTimeFormat(timeString)) {
			throw (std::runtime_error(EXCEPTION_INVALID_TIME_FORMAT));
		}
	}catch (...) {
		throw;
	}

	std::istringstream timeInput(timeString);
	timeInput >> time;

	try {
		if (!isValidTime(time)){
			throw (std::runtime_error(EXCEPTION_INVALID_TIME_INPUT));
		}
	}catch (...) {
		throw;
	}

	return time;
}

/*
	Purpose: Takes a day keyword and changes it into its corresponding date string.
	Pre-conditions: Parameter dayKeyword is valid, dateStrings vector has been initialised correctly.
	Post-conditions: Returns date string corresponding to day keyword input by user. 
*/
std::string Parse::changeDayToDate(std::string dayKeyword, std::vector<std::string> dateStrings){
	dayKeyword = convertToLowercase(dayKeyword);
	if (dayKeyword == DAY_KEYWORD_TODAY){
		return dateStrings[0];
	}else if (dayKeyword == DAY_KEYWORD_MONDAY || dayKeyword == DAY_KEYWORD_MON){
		return dateStrings[1]; 
	}else if (dayKeyword == DAY_KEYWORD_TUESDAY || dayKeyword == DAY_KEYWORD_TUES || dayKeyword == DAY_KEYWORD_TUE){
		return dateStrings[2]; 
	}else if (dayKeyword == DAY_KEYWORD_WEDNESDAY || dayKeyword == DAY_KEYWORD_WED){
		return dateStrings[3];
	}else if (dayKeyword == DAY_KEYWORD_THURSDAY || dayKeyword == DAY_KEYWORD_THURS|| dayKeyword == DAY_KEYWORD_THUR || dayKeyword == DAY_KEYWORD_THU){
		return dateStrings[4]; 
	}else if (dayKeyword == DAY_KEYWORD_FRIDAY || dayKeyword == DAY_KEYWORD_FRI){
		return dateStrings[5]; 
	}else if (dayKeyword == DAY_KEYWORD_SATURDAY || dayKeyword == DAY_KEYWORD_SAT){
		return dateStrings[6]; 
	}else if (dayKeyword == DAY_KEYWORD_SUNDAY || dayKeyword == DAY_KEYWORD_SUN){
		return dateStrings[7]; 
	}else if (dayKeyword == DAY_KEYWORD_TOMORROW || dayKeyword == DAY_KEYWORD_TMR){
		return dateStrings[8];
	}
	
	return NULL;
}

/*
	Purpose: Takes a word and changes changes it into lowercase form.
	Pre-conditions: Word is a string.
	Post-conditions: Returns word in lowercase if it is made up by letters. 
*/
std::string Parse::convertToLowercase(std::string word){
	for (unsigned int i = 0; word[i] != '\0'; i++){
		word[i] = tolower(word[i]);
	}

	return word;
}

//-----CHECK METHODS---------------------------------------------------------------------------

/*
	Purpose: Checks if word is a keyword or not.
	Pre-conditions: String word has been initialised.
	Post-conditions: Returns true if it is a keyword and false otherwise.
	Equivalence Partitions: valid keyword, invalid keyword
*/
bool Parse::isKeyword(std::string word){
	word = convertToLowercase(word);
	return (word == KEYWORD_DEADLINE || word == KEYWORD_ENDING || word == KEYWORD_LOCATION || word == KEYWORD_STARTING || word == KEYWORD_BLOCK);
}

/*
	Purpose: Checks if word is a valid day keyword or not. 
	Pre-conditions: String word has been initialised. 
	Post-conditions: Returns true if it is a day keyword and false otherwise. 
	Equivalence Partitions: valid day keyword, invalid day keyword
*/
bool Parse::isDayKeyword(std::string word){
	std::string dayKeywords[20] = {DAY_KEYWORD_TODAY, DAY_KEYWORD_TOMORROW, DAY_KEYWORD_TMR, DAY_KEYWORD_MONDAY, DAY_KEYWORD_MON, DAY_KEYWORD_TUESDAY, DAY_KEYWORD_TUES, DAY_KEYWORD_TUE, DAY_KEYWORD_WEDNESDAY, DAY_KEYWORD_WED, DAY_KEYWORD_THURSDAY, DAY_KEYWORD_THURS, DAY_KEYWORD_THUR, DAY_KEYWORD_THU, DAY_KEYWORD_FRIDAY, DAY_KEYWORD_FRI, DAY_KEYWORD_SATURDAY, DAY_KEYWORD_SAT, DAY_KEYWORD_SUNDAY, DAY_KEYWORD_SUN};
	word = convertToLowercase(word);
	for (int i = 0; i < 20; i++){
		if (word == dayKeywords[i]){
			return true;
		}
	}

	return false;
}

/* 
	Purpose: Checks if the input year format is correct (yy or yyyy). 
	Pre-condition: String is not empty.
	Post-condition: Returns true if year string has 2/4 characters and false otherwise. 
	Equivalence Partitions: less than 2 characters,  2/3/4 characters, more than 4 characters
	Boundary values: 0/1/2/3/4/5 characters 
*/
bool Parse::isValidYearFormat(std::string yearString){
	return (yearString.size() == 2 || yearString.size() == 4);
}

/* 
	Purpose: Checks if the input month format is correct (m, mm). 
	Pre-condition: String is not empty.
	Post-condition: Returns true if month string has 1/2 characters and false otherwise. 
	Equivalence Partitions: less than 1 character, 1-2 characters, more than 2 characters
	Boundary values:  empty string, 1 character, 2 characters, 3 characters
*/
bool Parse::isValidMonthFormat(std::string monthString){
	return (monthString.size() == 1 || monthString.size() == 2);
}

/* 
	Purpose: Checks if the input day format is correct (d, dd). 
	Pre-condition: String is not empty.
	Post-condition: Returns true if day string has 1/2 characters and false otherwise. 
	Equivalence Partitions: less than 1 character, 1-2 characters, more than 2 characters
	Boundary values: empty string, 1 character, 2 characters, 3 characters
*/
bool Parse::isValidDayFormat(std::string dayString){
	return (dayString.size() == 1 || dayString.size() == 2);
}

/* 
	Purpose: Checks if the input time format is correct. 
	Pre-condition: String is not empty.
	Post-condition: Returns true if year string has 4 characters and false otherwise. 
	Equivalence Partitions: less than 4 characters, 4 characters, more than 4 characters
	Boundary values: 3 characters, 4 characters, 5 characters
*/
bool Parse::isValidTimeFormat(std::string timeString){
	return (timeString.size() == 4);
}

/* 
	Purpose: Checks if time value is valid. 
	Pre-condition: Time value has been initialised.
	Post-condition: Returns true if time is valid and false otherwise. 
*/
bool Parse::isValidTime(int time){
	int hour = time/100;
	int mins = time-(hour*100);

	return (isValidHour(hour) && isValidMins(mins));
}

/* 
	Purpose: Checks if hour value of time is valid. 
	Pre-condition: Hour value is an integer.
	Post-condition: Returns true if hour value of time is valid and false otherwise. 
	Equivalence Partitions: < 0, 1-23, > 23 
	Boundary values: -1, 0, 1, 22, 23, 24
*/
bool Parse::isValidHour(int hour){
	return (hour >= 0 && hour <= 23);
}

/* 
	Purpose: Checks if minutes value of time is valid. 
	Pre-condition: Minutes value is an integer.
	Post-condition: Returns true if minutes value of time is valid and false otherwise. 
	Equivalence Partitions: < 1, 1-59, > 59
	Boundary values: -1, 0, 1, 58, 59, 60
*/
bool Parse::isValidMins(int mins){
	return (mins >= 0 && mins <= 59);
}

/* 
	Purpose: Checks if end time is after start time. 
	Pre-condition: Time values are integers.
	Post-condition: Returns true if ending time value of time is after starting time and false otherwise. 
*/
bool Parse::isLaterTime(int time1, int time2){
	return (time1 < time2);
}

/*
	Purpose: Checks if times are equal.
	Pre-condition: Time values are integers.
	Post-condition: Returns true if times are of the same value and false if otherwise.
*/
bool Parse::isSameTime(int time1, int time2){
	return (time1 == time2);
}
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Parse.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Parse.h
	 */

#pragma once

#include <assert.h>
#include "Task.h"

class Parse{
private:
//-----CONSTANT STRINGS------------------------------------------------------------------------

	//KEYWORDS
	static const std::string KEYWORD_LOCATION;
	static const std::string KEYWORD_STARTING;
	static const std::string KEYWORD_ENDING;
	static const std::string KEYWORD_DEADLINE;
	static const std::string KEYWORD_HOURS;
	static const std::string KEYWORD_BLOCK;
	static const std::string KEYWORD_BLOCK_BRACKETS;

	//MISC
	static const std::string EMPTY_STRING;
	static const std::string SINGLE_SPACE;
	static const std::string DATE_SEPARATOR;
	static const std::string SYMBOL_DASH;
	static const std::string SYMBOL_COLLON;

	//DAY KEYWORDS
	static const std::string DAY_KEYWORD_TODAY;
	static const std::string DAY_KEYWORD_TOMORROW;
	static const std::string DAY_KEYWORD_TMR;
	static const std::string DAY_KEYWORD_MONDAY;
	static const std::string DAY_KEYWORD_MON;
	static const std::string DAY_KEYWORD_TUESDAY;
	static const std::string DAY_KEYWORD_TUES;
	static const std::string DAY_KEYWORD_TUE;
	static const std::string DAY_KEYWORD_WEDNESDAY;
	static const std::string DAY_KEYWORD_WED;
	static const std::string DAY_KEYWORD_THURSDAY;
	static const std::string DAY_KEYWORD_THURS;
	static const std::string DAY_KEYWORD_THUR;
	static const std::string DAY_KEYWORD_THU;
	static const std::string DAY_KEYWORD_FRIDAY;
	static const std::string DAY_KEYWORD_FRI;
	static const std::string DAY_KEYWORD_SATURDAY;
	static const std::string DAY_KEYWORD_SAT;
	static const std::string DAY_KEYWORD_SUNDAY;
	static const std::string DAY_KEYWORD_SUN;

	//-----EXCEPTION FEEDBACK MESSAGES-------------------------------------------------------------

	static const std::string Parse::EXCEPTION_NO_START_DATE;
	static const std::string Parse::EXCEPTION_NO_END_DATE;
	static const std::string Parse::EXCEPTION_NO_DEADLINE_DATE;
	static const std::string Parse::EXCEPTION_DATE_NO_YEAR;
	static const std::string Parse::EXCEPTION_DATE_NO_MONTH;
	static const std::string Parse::EXCEPTION_DATE_NO_DAY;
	static const std::string Parse::EXCEPTION_INVALID_YEAR_INPUT;
	static const std::string Parse::EXCEPTION_INVALID_MONTH_INPUT;
	static const std::string Parse::EXCEPTION_INVALID_DAY_INPUT;
	static const std::string Parse::EXCEPTION_INVALID_TIME_INPUT;
	static const std::string Parse::EXCEPTION_INVALID_YEAR_FORMAT;
	static const std::string Parse::EXCEPTION_INVALID_MONTH_FORMAT;
	static const std::string Parse::EXCEPTION_INVALID_DAY_FORMAT;
	static const std::string Parse::EXCEPTION_INVALID_TIME_FORMAT;
	static const std::string Parse::EXCEPTION_NOBLOCK_MULTIPLE_DATES;
	static const std::string Parse::EXCEPTION_NOBLOCK_MULTIPLE_TYPES;
	static const std::string Parse::EXCEPTION_MISSING_START_TIME;
	static const std::string Parse::EXCEPTION_MISSING_END_TIME;
	static const std::string Parse::EXCEPTION_END_BEFORE_START_DATE;
	static const std::string Parse::EXCEPTION_START_END_SAME;
	static const std::string Parse::EXCEPTION_END_BEFORE_START_TIME;

//-----CONSTANT INTEGERS-----------------------------------------------------------------------

	static const int EMPTY_TIME;

public:
//-----PROCESSING METHODS----------------------------------------------------------------------
	
	//Takes task string from user input and processes it into its various Task variables
	void processTaskStringFromUI(std::string, std::string &, std::string &, std::vector<Date> &, std::vector<int> &, std::vector<Date> &, std::vector<int> &, std::vector<Date> &, std::vector<int> &, bool &, std::vector<std::string> &);

	//Takes task string from file storage and processes it into its various Task variables
	void processTaskStringFromFile(std::string, std::string &, std::string &, std::vector<Date> &, std::vector<int> &, std::vector<Date> &, std::vector<int> &, std::vector<Date> &, std::vector<int> &, bool &);

//-----CONVERSION METHODS----------------------------------------------------------------------

	//Takes a date in string type and converts it into Date type
	Date convertToDate(std::string);

	//Takes a time in string type and converts it into integer type
	int convertToTime(std::string);

	//Takes a day keyword and changes it into its corresponding date string
	std::string changeDayToDate(std::string, std::vector<std::string>);

	//Takes a word and changes it into lowercase form
	std::string convertToLowercase(std::string word);

//-----CHECK METHODS---------------------------------------------------------------------------

	//Checks if word is a keyword or not
	bool isKeyword(std::string word);

	//Checks if word is a valid day keyword or not
	bool isDayKeyword(std::string);

	//Checks if the input year format is correct (yyyy)
	bool isValidYearFormat(std::string);

	//Checks if the input month format is correct (m, mm)
	bool isValidMonthFormat(std::string);
	
	//Checks if the input day format is correct (d,dd)
	bool isValidDayFormat(std::string);

	//Checks if the input time format is correct 
	bool isValidTimeFormat(std::string);

	//Checks if time value is valid 
	bool isValidTime(int);

	//Checks if hour value of time is valid
	bool isValidHour(int);

	//Checks if minutes value of time is valid
	bool isValidMins(int);

	//Checks if second time is after the first time
	bool isLaterTime(int, int);

	//Checks if times are equal
	bool isSameTime(int, int);
};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Parse.h





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Task.cpp
	 */

#include "Task.h"

//-----CONSTANT STRINGS------------------------------------------------------------------------

//KEYWORDS
const std::string Task::KEYWORD_LOCATION = "at";
const std::string Task::KEYWORD_STARTING = "from";
const std::string Task::KEYWORD_ENDING = "to";
const std::string Task::KEYWORD_DEADLINE = "by";
const std::string Task::KEYWORD_HOURS = "hrs";
const std::string Task::KEYWORD_BLOCK = "blockoff";
const std::string Task::KEYWORD_BLOCK_BRACKETS = "(blockoff)";

//MISC
const std::string Task::EMPTY_STRING = "";
const std::string Task::SINGLE_SPACE = " ";
const std::string Task::DATE_SEPARATOR = "/";
const std::string Task::SYMBOL_DASH = "-";
const std::string Task::SYMBOL_COLLON = ":";
const std::string Task::ZERO_DIGIT = "0";

//-----CONSTANT INTEGERS-----------------------------------------------------------------------

const int Task::EMPTY_TIME = -1;

//-----CONSTRUCTORS----------------------------------------------------------------------------

//Default constructor
Task::Task(){
}

/* 
	Purpose: Takes task variable values and constructs a task object.
	Pre-conditions: All variables values should be valid. (e.g. strings should not be NULL)
	Post-conditions: Formatted task output string is initialised and task object is constructed. 
*/
Task::Task(std::string action, std::string location, Date startingDate, int startingTime, Date endingDate, int endingTime, Date deadlineDate, int deadlineTime, bool block){
	_action = action;
	_location = location;
	_startingDate = startingDate;
	_startingTime = startingTime;
	_endingDate = endingDate;
	_endingTime = endingTime;
	_deadlineDate = deadlineDate;
	_deadlineTime = deadlineTime;
	_block = block;
	_task = formatTaskOutputString();
}

//-----GET METHODS-----------------------------------------------------------------------------

/* 
	Purpose: Retrieves formatted task output string.
	Pre-condition: Task object has initialised output task string value.
	Post-condition: Returns formatted output string. 
*/
std::string Task::getTask(){
	return _task;
}

/* 
	Purpose: Retrieves task action string.
	Pre-condition: Task object has initialised action string value.
	Post-condition: Returns action string.
*/
std::string Task::getAction(){
	return _action;
}

/* 
	Purpose: Retrieves task location string.
	Pre-condition: Task object has initialised location string value.
	Post-condition: Returns location string.
*/
std::string Task::getLocation(){
	return _location;
}

/* 
	Purpose: Retrieves task starting date.
	Pre-condition: Task object has initialised starting date value. (Either valid date or empty date i.e. 0/0/0)
	Post-condition: Returns starting date. 
*/
Date Task::getStartingDate(){
	return _startingDate;
}

/* 
	Purpose: Retrieves task starting time.
	Pre-condition: Task object has initialised starting time value. (Either valid time or empty time i.e. -1)
	Post-condition: Returns starting time. 
*/
int Task::getStartingTime(){
	return _startingTime;
}

/* 
	Purpose: Retrieves task ending date.
	Pre-condition: Task object has initialised ending date value. (Either valid date or empty date i.e. 0/0/0)
	Post-condition: Returns ending date. 
*/
Date Task::getEndingDate(){
	return _endingDate;
}

/* 
	Purpose: Retrieves task ending time.
	Pre-condition: Task object has initialised ending time value. (Either valid time or empty time i.e. -1)
	Post-condition: Returns ending time. 
*/
int Task::getEndingTime(){
	return _endingTime;
}

/* 
	Purpose: Retrieves task deadline date.
	Pre-condition: Task object has initialised deadline date value. (Either valid date or empty date i.e. 0/0/0)
	Post-condition: Returns deadline date. 
*/
Date Task::getDeadlineDate(){
	return _deadlineDate;
}

/* 
	Purpose: Retrieves task deadline time.
	Pre-condition: Task object has initialised deadline time value. (Either valid time or empty time i.e. -1)
	Post-condition: Returns deadline time. 
*/
int Task::getDeadlineTime(){
	return _deadlineTime;
}

/* 
	Purpose: Checks if task is part of a block.
	Pre-condition: Task object has initialised block value.
	Post-condition: Returns true if task is part of a block and false if otherwise.
*/
bool Task::getBlock(){
	return _block;
}

//-----SET METHODS-----------------------------------------------------------------------------

/* 
	Purpose: Set whether task is part of a block or not.
	Pre-condition: Task object has been initialised.
	Post-condition: Task block variable and formatted task output string are updated. 
*/
void Task::setBlock(bool newBlock){
	_block = newBlock;     
	_task = formatTaskOutputString();
	
	return;
}

//-----FORMATTING METHODS----------------------------------------------------------------------

/* 
	Purpose: Formats task output string to be displayed to user.
	Pre-condition: Task object variables have been initialised.
	Post-condition: Returns formatted task output string.
*/
std::string Task::formatTaskOutputString(){
	std::ostringstream output;
	if (isDeadlineType()){
		output << KEYWORD_DEADLINE + SINGLE_SPACE;
		if (!_deadlineDate.isEmptyDate()){
			output << formatDateOutputString(_deadlineDate);
		}
		if (_deadlineTime != EMPTY_TIME){
			output << SINGLE_SPACE + formatTimeOutputString(_deadlineTime) + SINGLE_SPACE + KEYWORD_HOURS;
		}
		output << SINGLE_SPACE + SYMBOL_COLLON + SINGLE_SPACE + _action;
		if (!_location.empty()){
			output << SINGLE_SPACE + KEYWORD_LOCATION + SINGLE_SPACE + _location;
		}
		if (_block){
			output << SINGLE_SPACE + KEYWORD_BLOCK_BRACKETS;
		}
	}
	else if (isActivityType()){
		output << SINGLE_SPACE + SINGLE_SPACE + SINGLE_SPACE;	//For alignment with deadline tasks during display
		output << formatDateOutputString(_startingDate);
		if (_startingTime != EMPTY_TIME){
			output << SINGLE_SPACE + formatTimeOutputString(_startingTime) + SINGLE_SPACE + KEYWORD_HOURS;
		}
		if (!_endingDate.isEmptyDate()){
			output << SINGLE_SPACE + SYMBOL_DASH + SINGLE_SPACE + formatDateOutputString(_endingDate);
			if (_endingTime != EMPTY_TIME){
				output << SINGLE_SPACE + formatTimeOutputString(_endingTime) + SINGLE_SPACE + KEYWORD_HOURS;
			}
		}
		output << SINGLE_SPACE + SYMBOL_COLLON + SINGLE_SPACE + _action;
		if (!_location.empty()){
			output << SINGLE_SPACE + KEYWORD_LOCATION + SINGLE_SPACE + _location;
		}
		if (_block){
			output << SINGLE_SPACE + KEYWORD_BLOCK_BRACKETS;
		}
	}
	else if (isFloatingType()){
		output << SINGLE_SPACE + SINGLE_SPACE + SINGLE_SPACE; //For alignment with deadline tasks during display
		output << _action;
		if (!_location.empty()){
			output << SINGLE_SPACE + KEYWORD_LOCATION + SINGLE_SPACE + _location;
		}
	}

	return output.str();
}

/* 
	Purpose: Formats time output string based on time integer value. 
	Pre-condition: Time is valid and not empty (i.e. -1)
	Post-condition: Returns time output string in 24hr format (should be 4 digits) 
*/
std::string Task::formatTimeOutputString(int time){
	std::ostringstream timeString;

	if (time < 1000){
		timeString << ZERO_DIGIT;	//Adds zeros for values that are of less 
	}								//than 4 digits
	if (time < 100){
		timeString << ZERO_DIGIT;
	}
	if (time < 10){
		timeString << ZERO_DIGIT;
	}
	timeString << time;

	return timeString.str();
}

/* 
	Purpose: Formats date output string based on dd/mm/yyyy. 
	Pre-condition: Date is valid and not empty (i.e. 0/0/0).
	Post-condition: Returns date output string (should be in dd/mm/yyyy format).
*/

std::string Task::formatDateOutputString(Date date){
	std::ostringstream dateString;
	if (date._day < 10){
		dateString << ZERO_DIGIT;		//Adds zeros for day and month values that are 
	}									//single digits to ensure proper format
	dateString << date._day;
	dateString << DATE_SEPARATOR;
	if (date._month < 10){
		dateString << ZERO_DIGIT;
	}
	dateString << date._month;
	dateString << DATE_SEPARATOR;
	dateString << date._year;

	return dateString.str();
}

//-----CHECK METHODS---------------------------------------------------------------------------

/* 
	Purpose: Checks if task is a deadline type. 
	Pre-condition: Task object deadline date values have been initialised.
	Post-condition: Returns true if deadlineDate is not empty (i.e. 0/0/0) and false otherwise. 
	Equivalence Partitions: day/month/year = 0, valid integer values.
	Boundary values: 0, 1
*/
bool Task::isDeadlineType(){
	return !_deadlineDate.isEmptyDate();
}

/* 
	Purpose: Checks if task is an activity type. 
	Pre-condition: Task object date values have been initialised.
	Post-condition: Returns true if startingDate is not empty (i.e. 0/0/0) and false otherwise. 
*/

bool Task::isActivityType(){
	return !_startingDate.isEmptyDate();
}

/* 
	Purpose: Checks if task is an floating type (only contains action and no dates/times). 
	Pre-condition: Task object date values have been initialised.
	Post-condition: Returns true if all types of dates are empty (i.e. 0/0/0) and false otherwise. 
*/

bool Task::isFloatingType(){
	return _deadlineDate.isEmptyDate() && _startingDate.isEmptyDate() && _endingDate.isEmptyDate();
}
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Task.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Task.h
	 */

#pragma once

#include <string>
#include <vector>
#include <sstream>
#include "Date.h"


class Task{
private:
	std::string _task;		//Formatted task output string 
	std::string _action;	//Task action string
	std::string _location;	//Task location string
	Date _startingDate;		
	int	_startingTime;		
	Date _endingDate;
	int _endingTime;
	Date _deadlineDate;
	int	_deadlineTime;
	bool _block;			//Indicates if task is part of a block

//-----CONSTANT STRINGS------------------------------------------------------------------------

	//KEYWORDS
	static const std::string KEYWORD_LOCATION;
	static const std::string KEYWORD_STARTING;
	static const std::string KEYWORD_ENDING;
	static const std::string KEYWORD_DEADLINE;
	static const std::string KEYWORD_HOURS;
	static const std::string KEYWORD_BLOCK;
	static const std::string KEYWORD_BLOCK_BRACKETS;

	//MISC
	static const std::string EMPTY_STRING;
	static const std::string SINGLE_SPACE;
	static const std::string DATE_SEPARATOR;
	static const std::string SYMBOL_DASH;
	static const std::string SYMBOL_COLLON;
	static const std::string ZERO_DIGIT;

//-----CONSTANT INTEGERS-----------------------------------------------------------------------

	static const int EMPTY_TIME;

public:
//-----CONSTRUCTORS----------------------------------------------------------------------------

	//Default constructor
	Task();

	//Constructor with parameters
	Task(std::string, std::string, Date, int, Date, int, Date, int, bool);

//-----GET METHODS-----------------------------------------------------------------------------

	//Returns formatted task output string
	std::string getTask();

	//Returns task action string
	std::string getAction();

	//Returns task location string
	std::string getLocation();

	//Returns task starting date
	Date getStartingDate();

	//Returns task starting time
	int getStartingTime();

	//Returns task ending date
	Date getEndingDate();

	//Returns task ending time
	int getEndingTime();

	//Returns task deadline date
	Date getDeadlineDate();

	//Returns task deadline time
	int getDeadlineTime();

	//Returns whether task is part of a block
	bool getBlock();

//-----SET METHODS-----------------------------------------------------------------------------

	//Set whether task is part of a block
	void setBlock(bool);

//-----FORMATTING METHODS----------------------------------------------------------------------

	//Formats the task output string for display to user
	std::string Task::formatTaskOutputString();

	//Formats the time output string from integer type value
	std::string formatTimeOutputString(int);

	//Formats the date output string from date type value
	std::string formatDateOutputString(Date);

//-----CHECK METHODS---------------------------------------------------------------------------
	
	//Checks if task is deadline type
	bool isDeadlineType();
	
	//Checks if task is activity type (from-to)
	bool isActivityType();

	//Checks if task is floating type
	bool isFloatingType();
	
	//Checks if date value is empty i.e. 0/0/0
	bool isEmptyDate(Date);

	//Checks if date value is valid
	bool isValidDate(Date);

	//Checks if day value of date is valid
	bool isValidDay(int);

	//Checks if month value of date is valid
	bool isValidMonth(int);

	//Checks if year value of date is valid
	bool isValidYear(int);

	//Checks if time value is empty i.e. -1
	bool isEmptyTime(int);

	//Checks if time value is valid 
	bool isValidTime(int);

	//Checks if hour value of time is valid i.e. between 0-23
	bool isValidHour(int);

	//Checks if minutes value of time is valid i.e. between 0-59
	bool isValidMins(int);
};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\Task.h





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\DateTest.cpp
	 */

#include <gtest\gtest.h>
#include "DateTest.h"

TEST_F(DateTest, ConstructDefaultEmptyDate){
	Date date; 
	EXPECT_EQ(0, date._day);
	EXPECT_EQ(0, date._month);
	EXPECT_EQ(0, date._year);
	EXPECT_EQ(true, date.isEmptyDate());
}

TEST_F(DateTest, ConstructDateWithInvalidDay){
	Date date(32,1,2013);
	EXPECT_EQ(false, date.isValidDate());
	EXPECT_EQ(false, date.isValidDay());
	EXPECT_EQ(true, date.isValidMonth());
}

TEST_F(DateTest, ConstructDateWithInvalidMonth){
	Date date(31,13,2013);
	EXPECT_EQ(false, date.isValidDate());
	EXPECT_EQ(true, date.isValidDay());
	EXPECT_EQ(false, date.isValidMonth());
}

TEST_F(DateTest, CheckForComparingDates){
	EXPECT_EQ(true, date1.isLaterDate(date2));
	EXPECT_EQ(false, date2.isLaterDate(date1));
	EXPECT_EQ(false, date1.isSameDate(date2));
	EXPECT_EQ(true, date1.isSameDate(date3));
	EXPECT_EQ(false, date1.isLaterDate(date3));
}


	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\DateTest.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\DateTest.h
	 */

#include <gtest\gtest.h>
#include <Date.h>

class DateTest : public ::testing::Test {
protected:
	virtual void SetUp(){
		date1._day = 11;
		date1._month = 11;
		date1._year = 2013;
		date2._day = 27;
		date2._month = 11;
		date2._year = 2013;
		date3._day = 11;
		date3._month = 11;
		date3._year = 2013;
	}
	Date date1;
	Date date2;
	Date date3;
};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\DateTest.h





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\ParseTest.cpp
	 */

#include <gtest\gtest.h>
#include "ParseTest.h"

TEST_F(ParseTest, DateStringToDateConversion){
	Date checkDate(1,1,2013);

	// d/m/yyyy format
	std::string dateString1 = "1/1/2013";
	Date date1 = taskParse.convertToDate(dateString1);
	EXPECT_EQ(checkDate._day, date1._day);
	EXPECT_EQ(checkDate._month, date1._month);
	EXPECT_EQ(checkDate._year, date1._year);

	// dd/m/yy format
	std::string dateString2 = "01/1/13";
	Date date2 = taskParse.convertToDate(dateString2);
	EXPECT_EQ(checkDate._day, date2._day);
	EXPECT_EQ(checkDate._month, date2._month);
	EXPECT_EQ(checkDate._year, date2._year);

	// d/mm/yyyy format
	std::string dateString3 = "1/01/2013";
	Date date3 = taskParse.convertToDate(dateString3);
	EXPECT_EQ(checkDate._day, date3._day);
	EXPECT_EQ(checkDate._month, date3._month);
	EXPECT_EQ(checkDate._year, date3._year);

	// dd/mm/yy format
	std::string dateString4 = "01/01/13";
	Date date4 = taskParse.convertToDate(dateString4);
	EXPECT_EQ(checkDate._day, date4._day);
	EXPECT_EQ(checkDate._month, date4._month);
	EXPECT_EQ(checkDate._year, date4._year);
}

TEST_F(ParseTest, TimeStringToIntTimeConversion){
	//Single digit
	std::string timeString1 = "0001";
	int timeValue1 = 1;
	EXPECT_EQ(timeValue1, taskParse.convertToTime(timeString1));
	
	//Double digit
	std::string timeString2 = "0010";
	int timeValue2 = 10;
	EXPECT_EQ(timeValue2, taskParse.convertToTime(timeString2));
	
	//Triple digit
	std::string timeString3 = "0100";
	int timeValue3 = 100;
	EXPECT_EQ(timeValue3, taskParse.convertToTime(timeString3));
	
	//Four digits
	std::string timeString4 = "1000";
	int timeValue4 = 1000;
	EXPECT_EQ(timeValue4, taskParse.convertToTime(timeString4));
}

TEST_F(ParseTest, DayKeywordToDateStringConversion){
	//Initialise dateStrings vector given that today is 11/11/2013
	std::vector<std::string> dateStrings;
	dateStrings.push_back("11/11/2013");
	for (unsigned int i = 0; i < 7; i++){
		std::ostringstream dateString;
		int dateValue = 11 + i;
		dateString << dateValue;
		dateStrings.push_back(dateString.str()+"/11/2013");
	}
	dateStrings.push_back("12/11/2013");

	EXPECT_EQ("11/11/2013", taskParse.changeDayToDate("today", dateStrings));
	EXPECT_EQ("11/11/2013", taskParse.changeDayToDate("Mon", dateStrings));
	EXPECT_EQ("11/11/2013", taskParse.changeDayToDate("monday", dateStrings));
	EXPECT_EQ("12/11/2013", taskParse.changeDayToDate("tues", dateStrings));
	EXPECT_EQ("12/11/2013", taskParse.changeDayToDate("Tue", dateStrings));
	EXPECT_EQ("12/11/2013", taskParse.changeDayToDate("tuesday", dateStrings));
	EXPECT_EQ("13/11/2013", taskParse.changeDayToDate("wed", dateStrings));
	EXPECT_EQ("13/11/2013", taskParse.changeDayToDate("WEDNESDAY", dateStrings));
	EXPECT_EQ("14/11/2013", taskParse.changeDayToDate("Thursday", dateStrings));
	EXPECT_EQ("14/11/2013", taskParse.changeDayToDate("thu", dateStrings));
	EXPECT_EQ("14/11/2013", taskParse.changeDayToDate("thurs", dateStrings));
	EXPECT_EQ("14/11/2013", taskParse.changeDayToDate("Thur", dateStrings));
	EXPECT_EQ("15/11/2013", taskParse.changeDayToDate("friday", dateStrings));
	EXPECT_EQ("15/11/2013", taskParse.changeDayToDate("fri", dateStrings));
	EXPECT_EQ("16/11/2013", taskParse.changeDayToDate("Sat", dateStrings));
	EXPECT_EQ("16/11/2013", taskParse.changeDayToDate("saturday", dateStrings));
	EXPECT_EQ("17/11/2013", taskParse.changeDayToDate("SUN", dateStrings));
	EXPECT_EQ("17/11/2013", taskParse.changeDayToDate("sunday", dateStrings));
	EXPECT_EQ("12/11/2013", taskParse.changeDayToDate("tmr", dateStrings));
	EXPECT_EQ("12/11/2013", taskParse.changeDayToDate("tomorrow", dateStrings));
}

TEST_F(ParseTest, LowercaseConversion){
	std::string checkWord = "word";

	std::string word1 = "Word";
	EXPECT_EQ(checkWord, taskParse.convertToLowercase(word1)); 
	
	std::string word2 = "wORd";
	EXPECT_EQ(checkWord, taskParse.convertToLowercase(word2));
	
	std::string word3 = "worD";
	EXPECT_EQ(checkWord, taskParse.convertToLowercase(word3));
	
	std::string word4 = "WORD";
	EXPECT_EQ(checkWord, taskParse.convertToLowercase(word4));
}

TEST_F(ParseTest, ProcessTaskStringFromUI){
	std::string action;
	std::string location;
	std::vector<Date> startingDate;
	std::vector<int> startingTime;
	std::vector<Date> endingDate;
	std::vector<int> endingTime;
	std::vector<Date> deadlineDate;
	std::vector<int> deadlineTime;
	bool block;
	//Initialise dateStrings vector given that today is 11/11/2013
	std::vector<std::string> dateStrings;
	dateStrings.push_back("11/11/2013");
	for (unsigned int i = 0; i < 7; i++){
		std::ostringstream dateString;
		int dateValue = 11 + i;
		dateString << dateValue;
		dateStrings.push_back(dateString.str()+"/11/2013");
	}
	dateStrings.push_back("12/11/2013");

	//Floating task with location
	std::string userInput1 = "have lunch with parents at macs";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromUI(userInput1, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block, dateStrings);

	EXPECT_EQ("have lunch with parents", action);
	EXPECT_EQ("macs", location);
	EXPECT_EQ(1, startingDate.size());
	EXPECT_EQ(0, startingDate[0]._day);
	EXPECT_EQ(0, startingDate[0]._month);
	EXPECT_EQ(0, startingDate[0]._year);
	EXPECT_EQ(1, startingTime.size());
	EXPECT_EQ(-1, startingTime[0]);
	EXPECT_EQ(1, endingDate.size());
	EXPECT_EQ(0, endingDate[0]._day);
	EXPECT_EQ(0, endingDate[0]._month);
	EXPECT_EQ(0, endingDate[0]._year);
	EXPECT_EQ(1, endingTime.size());
	EXPECT_EQ(-1, endingTime[0]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(0, deadlineDate[0]._day);
	EXPECT_EQ(0, deadlineDate[0]._month);
	EXPECT_EQ(0, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(-1, deadlineTime[0]);
	EXPECT_EQ(false, block);

	//Activity task with date date strings with different day formats
	std::string userInput2 = "sleepover with jc friends from 3/12/2013 to 04/12/2013";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromUI(userInput2, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block, dateStrings);

	EXPECT_EQ("sleepover with jc friends", action);
	EXPECT_EQ("", location);
	EXPECT_EQ(1, startingDate.size());
	EXPECT_EQ(3, startingDate[0]._day);
	EXPECT_EQ(12, startingDate[0]._month);
	EXPECT_EQ(2013, startingDate[0]._year);
	EXPECT_EQ(1, startingTime.size());
	EXPECT_EQ(-1, startingTime[0]);
	EXPECT_EQ(1, endingDate.size());
	EXPECT_EQ(4, endingDate[0]._day);
	EXPECT_EQ(12, endingDate[0]._month);
	EXPECT_EQ(2013, endingDate[0]._year);
	EXPECT_EQ(1, endingTime.size());
	EXPECT_EQ(-1, endingTime[0]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(0, deadlineDate[0]._day);
	EXPECT_EQ(0, deadlineDate[0]._month);
	EXPECT_EQ(0, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(-1, deadlineTime[0]);
	EXPECT_EQ(false, block);

	//Deadline task with day keyword and time
	std::string userInput3 = "submit cs2103 taskbuddy program v0.5 by TODAY 2359";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromUI(userInput3, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block, dateStrings);

	EXPECT_EQ("submit cs2103 taskbuddy program v0.5", action);
	EXPECT_EQ("", location);
	EXPECT_EQ(1, startingDate.size());
	EXPECT_EQ(0, startingDate[0]._day);
	EXPECT_EQ(0, startingDate[0]._month);
	EXPECT_EQ(0, startingDate[0]._year);
	EXPECT_EQ(1, startingTime.size());
	EXPECT_EQ(-1, startingTime[0]);
	EXPECT_EQ(1, endingDate.size());
	EXPECT_EQ(0, endingDate[0]._day);
	EXPECT_EQ(0, endingDate[0]._month);
	EXPECT_EQ(0, endingDate[0]._year);
	EXPECT_EQ(1, endingTime.size());
	EXPECT_EQ(-1, endingTime[0]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(11, deadlineDate[0]._day);
	EXPECT_EQ(11, deadlineDate[0]._month);
	EXPECT_EQ(2013, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(2359, deadlineTime[0]);
	EXPECT_EQ(false, block);

	//Blocked task with location and mixture of task types (with and without time)
	std::string userInput4 = "study for cs2103 finals at mac commons blockoff from 11/11/13 1300 to today 1900 by today 2100 from mon to 13/11/2013 from Tues 0800";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromUI(userInput4, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block, dateStrings);

	EXPECT_EQ("study for cs2103 finals", action);
	EXPECT_EQ("mac commons", location);
	EXPECT_EQ(3, startingDate.size());
	EXPECT_EQ(11, startingDate[0]._day);
	EXPECT_EQ(11, startingDate[0]._month);
	EXPECT_EQ(2013, startingDate[0]._year);
	EXPECT_EQ(11, startingDate[1]._day);
	EXPECT_EQ(11, startingDate[1]._month);
	EXPECT_EQ(2013, startingDate[1]._year);
	EXPECT_EQ(12, startingDate[2]._day);
	EXPECT_EQ(11, startingDate[2]._month);
	EXPECT_EQ(2013, startingDate[2]._year);
	EXPECT_EQ(3, startingTime.size());
	EXPECT_EQ(1300, startingTime[0]);
	EXPECT_EQ(-1, startingTime[1]);
	EXPECT_EQ(800, startingTime[2]);
	EXPECT_EQ(3, endingDate.size());
	EXPECT_EQ(11, endingDate[0]._day);
	EXPECT_EQ(11, endingDate[0]._month);
	EXPECT_EQ(2013, endingDate[0]._year);
	EXPECT_EQ(13, endingDate[1]._day);
	EXPECT_EQ(11, endingDate[1]._month);
	EXPECT_EQ(2013, endingDate[1]._year);
	EXPECT_EQ(0, endingDate[2]._day);
	EXPECT_EQ(0, endingDate[2]._month);
	EXPECT_EQ(0, endingDate[2]._year);
	EXPECT_EQ(3, endingTime.size());
	EXPECT_EQ(1900, endingTime[0]);
	EXPECT_EQ(-1, endingTime[1]);
	EXPECT_EQ(-1, endingTime[2]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(11, deadlineDate[0]._day);
	EXPECT_EQ(11, deadlineDate[0]._month);
	EXPECT_EQ(2013, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(2100, deadlineTime[0]);
	EXPECT_EQ(true, block);

	//Activity task with start and end date with single digit day/month input format
	std::string userInput5 = "family overseas holiday from 22/12/2013 to 6/1/2014";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromUI(userInput5, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block, dateStrings);

	EXPECT_EQ("family overseas holiday", action);
	EXPECT_EQ("", location);
	EXPECT_EQ(1, startingDate.size());
	EXPECT_EQ(22, startingDate[0]._day);
	EXPECT_EQ(12, startingDate[0]._month);
	EXPECT_EQ(2013, startingDate[0]._year);
	EXPECT_EQ(1, startingTime.size());
	EXPECT_EQ(-1, startingTime[0]);
	EXPECT_EQ(1, endingDate.size());
	EXPECT_EQ(6, endingDate[0]._day);
	EXPECT_EQ(1, endingDate[0]._month);
	EXPECT_EQ(2014, endingDate[0]._year);
	EXPECT_EQ(1, endingTime.size());
	EXPECT_EQ(-1, endingTime[0]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(0, deadlineDate[0]._day);
	EXPECT_EQ(0, deadlineDate[0]._month);
	EXPECT_EQ(0, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(-1, deadlineTime[0]);
	EXPECT_EQ(false, block);
}

TEST_F(ParseTest, ProcessTaskFromFile){
	std::string action;
	std::string location;
	std::vector<Date> startingDate;
	std::vector<int> startingTime;
	std::vector<Date> endingDate;
	std::vector<int> endingTime;
	std::vector<Date> deadlineDate;
	std::vector<int> deadlineTime;
	bool block;

	//Floating task with location
	std::string fileTask1 = "   have lunch with parents at macs";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromFile(fileTask1, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);
	
	EXPECT_EQ("have lunch with parents", action);
	EXPECT_EQ("macs", location);
	EXPECT_EQ(1, startingDate.size());
	EXPECT_EQ(0, startingDate[0]._day);
	EXPECT_EQ(0, startingDate[0]._month);
	EXPECT_EQ(0, startingDate[0]._year);
	EXPECT_EQ(1, startingTime.size());
	EXPECT_EQ(-1, startingTime[0]);
	EXPECT_EQ(1, endingDate.size());
	EXPECT_EQ(0, endingDate[0]._day);
	EXPECT_EQ(0, endingDate[0]._month);
	EXPECT_EQ(0, endingDate[0]._year);
	EXPECT_EQ(1, endingTime.size());
	EXPECT_EQ(-1, endingTime[0]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(0, deadlineDate[0]._day);
	EXPECT_EQ(0, deadlineDate[0]._month);
	EXPECT_EQ(0, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(-1, deadlineTime[0]);
	EXPECT_EQ(false, block);

	//Activity task with start and end date with single digit day and double digit month
	std::string fileTask2 = "   03/12/2013 - 04/12/2013 : sleepover with jc friends";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromFile(fileTask2, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);

	EXPECT_EQ("sleepover with jc friends", action);
	EXPECT_EQ("", location);
	EXPECT_EQ(1, startingDate.size());
	EXPECT_EQ(3, startingDate[0]._day);
	EXPECT_EQ(12, startingDate[0]._month);
	EXPECT_EQ(2013, startingDate[0]._year);
	EXPECT_EQ(1, startingTime.size());
	EXPECT_EQ(-1, startingTime[0]);
	EXPECT_EQ(1, endingDate.size());
	EXPECT_EQ(4, endingDate[0]._day);
	EXPECT_EQ(12, endingDate[0]._month);
	EXPECT_EQ(2013, endingDate[0]._year);
	EXPECT_EQ(1, endingTime.size());
	EXPECT_EQ(-1, endingTime[0]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(0, deadlineDate[0]._day);
	EXPECT_EQ(0, deadlineDate[0]._month);
	EXPECT_EQ(0, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(-1, deadlineTime[0]);
	EXPECT_EQ(false, block);

	//Deadline task with time
	std::string fileTask3 = "by 11/11/2013 2359 hrs : submit cs2103 taskbuddy program v0.5";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromFile(fileTask3, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);

	EXPECT_EQ("submit cs2103 taskbuddy program v0.5", action);
	EXPECT_EQ("", location);
	EXPECT_EQ(1, startingDate.size());
	EXPECT_EQ(0, startingDate[0]._day);
	EXPECT_EQ(0, startingDate[0]._month);
	EXPECT_EQ(0, startingDate[0]._year);
	EXPECT_EQ(1, startingTime.size());
	EXPECT_EQ(-1, startingTime[0]);
	EXPECT_EQ(1, endingDate.size());
	EXPECT_EQ(0, endingDate[0]._day);
	EXPECT_EQ(0, endingDate[0]._month);
	EXPECT_EQ(0, endingDate[0]._year);
	EXPECT_EQ(1, endingTime.size());
	EXPECT_EQ(-1, endingTime[0]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(11, deadlineDate[0]._day);
	EXPECT_EQ(11, deadlineDate[0]._month);
	EXPECT_EQ(2013, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(2359, deadlineTime[0]);
	EXPECT_EQ(false, block);

	//Blocked activity task with start date and time
	std::string fileTask4 = "   12/11/2013 0800 hrs : study for cs2103 finals at mac commons (blockoff)";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromFile(fileTask4, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);

	EXPECT_EQ("study for cs2103 finals", action);
	EXPECT_EQ("mac commons", location);
	EXPECT_EQ(1, startingDate.size());
	EXPECT_EQ(12, startingDate[0]._day);
	EXPECT_EQ(11, startingDate[0]._month);
	EXPECT_EQ(2013, startingDate[0]._year);
	EXPECT_EQ(1, startingTime.size());
	EXPECT_EQ(800, startingTime[0]);
	EXPECT_EQ(1, endingDate.size());
	EXPECT_EQ(0, endingDate[0]._day);
	EXPECT_EQ(0, endingDate[0]._month);
	EXPECT_EQ(0, endingDate[0]._year);
	EXPECT_EQ(1, endingTime.size());
	EXPECT_EQ(-1, endingTime[0]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(0, deadlineDate[0]._day);
	EXPECT_EQ(0, deadlineDate[0]._month);
	EXPECT_EQ(0, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(-1, deadlineTime[0]);
	EXPECT_EQ(true, block);

	//Activity task with start and end date with single digit day/month 
	std::string fileTask5 = "   22/12/2013 - 06/01/2014 : family overseas holiday";
	action = "";
	location = "";
	startingDate.clear();
	startingTime.clear();
	endingDate.clear();
	endingTime.clear();
	deadlineDate.clear();
	deadlineTime.clear();
	block = false;
	taskParse.processTaskStringFromFile(fileTask5, action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);

	EXPECT_EQ("family overseas holiday", action);
	EXPECT_EQ("", location);
	EXPECT_EQ(1, startingDate.size());
	EXPECT_EQ(22, startingDate[0]._day);
	EXPECT_EQ(12, startingDate[0]._month);
	EXPECT_EQ(2013, startingDate[0]._year);
	EXPECT_EQ(1, startingTime.size());
	EXPECT_EQ(-1, startingTime[0]);
	EXPECT_EQ(1, endingDate.size());
	EXPECT_EQ(6, endingDate[0]._day);
	EXPECT_EQ(1, endingDate[0]._month);
	EXPECT_EQ(2014, endingDate[0]._year);
	EXPECT_EQ(1, endingTime.size());
	EXPECT_EQ(-1, endingTime[0]);
	EXPECT_EQ(1, deadlineDate.size());
	EXPECT_EQ(0, deadlineDate[0]._day);
	EXPECT_EQ(0, deadlineDate[0]._month);
	EXPECT_EQ(0, deadlineDate[0]._year);
	EXPECT_EQ(1, deadlineTime.size());
	EXPECT_EQ(-1, deadlineTime[0]);
	EXPECT_EQ(false, block);
}

TEST_F(ParseTest, CheckForKeyword){
	//Check that not affected by case
	std::string fromUppercase = "FROM";
	std::string byCapitalised = "By";
	std::string atLower = "at";
	std::string toUppercase = "TO";
	std::string blockBothcase = "bLOckOff";
	EXPECT_EQ(true, taskParse.isKeyword(fromUppercase));
	EXPECT_EQ(true, taskParse.isKeyword(byCapitalised));
	EXPECT_EQ(true, taskParse.isKeyword(atLower));
	EXPECT_EQ(true, taskParse.isKeyword(toUppercase));
	EXPECT_EQ(true, taskParse.isKeyword(blockBothcase));
}

TEST_F(ParseTest, CheckForDayKeyword){
	//Check that not affected by case 
	std::string todayLowercase = "today";
	std::string mondayUppercase = "MONDAY";
	std::string monLowercase = "mon";
	std::string tuesdayLowercase = "tuesday";
	std::string tueCapitalised = "Tue";
	std::string tuesUppercase = "TUES";
	std::string wednesdayLowercase = "wednesday";
	std::string wedBothcase = "wEd";
	std::string thursdayBothcase = "thuRsDAy";
	std::string thursUppercase = "THURS";
	std::string thurCapitalised = "Thur";
	std::string thuLowercase = "thu";
	std::string fridayCapitalised = "Friday";
	std::string friUppercase = "FRI";
	std::string saturdayBothcase = "SAturDaY";
	std::string satLowercase = "sat";
	std::string sundayCapitalised = "Sunday";
	std::string sunUppercase = "SUN";
	std::string tomorrowBothcase = "TOMorrOw";
	std::string tmrLowercase = "tmr";
	EXPECT_EQ(true, taskParse.isDayKeyword(todayLowercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(mondayUppercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(monLowercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(tuesdayLowercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(tuesUppercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(tueCapitalised));
	EXPECT_EQ(true, taskParse.isDayKeyword(wednesdayLowercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(wedBothcase));
	EXPECT_EQ(true, taskParse.isDayKeyword(thursdayBothcase));
	EXPECT_EQ(true, taskParse.isDayKeyword(thursUppercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(thurCapitalised));
	EXPECT_EQ(true, taskParse.isDayKeyword(thuLowercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(fridayCapitalised));
	EXPECT_EQ(true, taskParse.isDayKeyword(friUppercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(saturdayBothcase));
	EXPECT_EQ(true, taskParse.isDayKeyword(satLowercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(sundayCapitalised));
	EXPECT_EQ(true, taskParse.isDayKeyword(sunUppercase));
	EXPECT_EQ(true, taskParse.isDayKeyword(tomorrowBothcase));
	EXPECT_EQ(true, taskParse.isDayKeyword(tmrLowercase));
}

TEST_F(ParseTest, CheckForValidFormat){
	 //Check date input format
	std::string dayInput1 = "1";
	std::string dayInput2 = "01";
	std::string dayInput3 = "001";
	EXPECT_EQ(true, taskParse.isValidDayFormat(dayInput1));
	EXPECT_EQ(true, taskParse.isValidDayFormat(dayInput2));
	EXPECT_EQ(false, taskParse.isValidDayFormat(dayInput3));
	
	//Check month input format
	std::string monthInput1 = "1";
	std::string monthInput2 = "01";
	std::string monthInput3 = "001";
	EXPECT_EQ(true, taskParse.isValidMonthFormat(monthInput1));
	EXPECT_EQ(true, taskParse.isValidMonthFormat(monthInput2));
	EXPECT_EQ(false, taskParse.isValidMonthFormat(monthInput3));
	
	//Check year input format
	std::string yearInput1 = "1";
	std::string yearInput2 = "01";
	std::string yearInput3 = "150";
	std::string yearInput4 = "2013";
	std::string yearInput5 = "20133";
	EXPECT_EQ(false, taskParse.isValidYearFormat(yearInput1));
	EXPECT_EQ(true, taskParse.isValidYearFormat(yearInput2));
	EXPECT_EQ(false, taskParse.isValidYearFormat(yearInput3));
	EXPECT_EQ(true, taskParse.isValidYearFormat(yearInput4));
	EXPECT_EQ(false, taskParse.isValidYearFormat(yearInput5));
	
	//Check time input format
	std::string timeInput1 = "800";
	std::string timeInput2 = "1200";
	std::string timeInput3 = "12300";
	EXPECT_EQ(false, taskParse.isValidTimeFormat(timeInput1));
	EXPECT_EQ(true, taskParse.isValidTimeFormat(timeInput2));
	EXPECT_EQ(false, taskParse.isValidTimeFormat(timeInput3));
}

TEST_F(ParseTest, CheckForValidTime){
	//Check valid hour value
	int hour1 = 0;
	int hour2 = 1;
	int hour3 = 22; 
	int hour4 = 23;
	int hour5 = 24;
	EXPECT_EQ(true, taskParse.isValidHour(hour1));
	EXPECT_EQ(true, taskParse.isValidHour(hour2));
	EXPECT_EQ(true, taskParse.isValidHour(hour3));
	EXPECT_EQ(true, taskParse.isValidHour(hour4));
	EXPECT_EQ(false, taskParse.isValidHour(hour5));
	
	//Check valid mins value
	int mins1 = 0;
	int mins2 = 1;
	int mins3 = 58;
	int mins4 = 59;
	int mins5 = 60;
	EXPECT_EQ(true, taskParse.isValidMins(mins1));
	EXPECT_EQ(true, taskParse.isValidMins(mins2));
	EXPECT_EQ(true, taskParse.isValidMins(mins3));
	EXPECT_EQ(true, taskParse.isValidMins(mins4));
	EXPECT_EQ(false, taskParse.isValidMins(mins5));
	
	//Check valid time value
	int time1 = 0;
	int time2 = 2459;
	int time3 = 2360;
	int time4 = 59;
	int time5 = 2301;
	EXPECT_EQ(true, taskParse.isValidTime(time1));
	EXPECT_EQ(false, taskParse.isValidTime(time2));
	EXPECT_EQ(false, taskParse.isValidTime(time3));
	EXPECT_EQ(true, taskParse.isValidTime(time4));
	EXPECT_EQ(true, taskParse.isValidTime(time5));

}

	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\ParseTest.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\ParseTest.h
	 */

#include <gtest\gtest.h>
#include <Parse.h>
#include <Task.h>
#include <Date.h>
#include <sstream>

class ParseTest : public ::testing::Test {
protected:
	virtual void SetUp(){
	static const int EMPTY_TIME = -1;
	}

	Parse taskParse;

};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\ParseTest.h





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\TaskTest.cpp
	 */

#include "TaskTest.h"

TEST(TaskTest, FormatDateWithSingleDigitDay){
	Task task;
	Date date(1,10,2013);
	std::string expectedDateString = "01/10/2013";
	EXPECT_EQ(expectedDateString, task.formatDateOutputString(date));
}
TEST(TaskTest, FormatDateWithSingleDigitMonth){
	Task task;
	Date date(12,1,2013);
	std::string expectedDateString = "12/01/2013";
	EXPECT_EQ(expectedDateString, task.formatDateOutputString(date));
}

TEST(TaskTest, FormatDateWithSingleDigitDayAndMonth){
	Task task;
	Date date(1,1,2013);
	std::string expectedDateString = "01/01/2013";
	EXPECT_EQ(expectedDateString, task.formatDateOutputString(date));
}

TEST(TaskTest, FormatTimeWithSingleDigitValue){
	Task task;
	int time = 5;
	std::string expectedTimeString = "0005";
	EXPECT_EQ(expectedTimeString, task.formatTimeOutputString(time));
}

TEST(TaskTest, FormatTimeWithDoubleDigitValue){
	Task task;
	int time = 30;
	std::string expectedTimeString = "0030";
	EXPECT_EQ(expectedTimeString, task.formatTimeOutputString(time));
}

TEST(TaskTest, FormatTimeWithTripleDigitValue){
	Task task;
	int time = 845;
	std::string expectedTimeString = "0845";
	EXPECT_EQ(expectedTimeString, task.formatTimeOutputString(time));
}

TEST(TaskTest, FormatTimeWithFourDigitValue){
	Task task;
	int time = 1230;
	std::string expectedTimeString = "1230";
	EXPECT_EQ(expectedTimeString, task.formatTimeOutputString(time));
}

TEST(TaskTest, FormatFloatingTaskStringWithLocation){
	std::string action = "action";
	std::string location = "location";
	Date startingDate;
	int startingTime = -1;
	Date endingDate;
	int endingTime = -1;
	Date deadlineDate;
	int deadlineTime = -1;
	bool block = false;
	
	Task task(action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);
	std::string expectedTaskString = "   action at location";
	EXPECT_EQ(expectedTaskString, task.formatTaskOutputString());
}

TEST(TaskTest, FormatActivityTaskWithEndWithTime){
	std::string action = "action";
	std::string location = "";
	Date startingDate(11,11,2013);
	int startingTime = 800;
	Date endingDate(11,11,2013);
	int endingTime = 900;
	Date deadlineDate;
	int deadlineTime = -1;
	bool block = false; 

	Task task(action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);
	std::string expectedTaskString = "   11/11/2013 0800 hrs - 11/11/2013 0900 hrs : action";
	EXPECT_EQ(expectedTaskString, task.formatTaskOutputString());
}

TEST(TaskTest, FormatBlockedActivityTaskWithLocation){
	std::string action = "action";
	std::string location = "location";
	Date startingDate(11,11,2013);
	int startingTime = -1;
	Date endingDate;
	int endingTime = -1;
	Date deadlineDate;
	int deadlineTime = -1;
	bool block = true; 

	Task task(action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);
	std::string expectedTaskString = "   11/11/2013 : action at location (blockoff)";
	EXPECT_EQ(expectedTaskString, task.formatTaskOutputString());
}

TEST(TaskTest, FormatDeadlineTaskWithTime){
	std::string action = "action";
	std::string location = "";
	Date startingDate;
	int startingTime = -1;
	Date endingDate;
	int endingTime = -1;
	Date deadlineDate(11,11,2013);
	int deadlineTime = 2359;
	bool block = false; 

	Task task(action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);
	std::string expectedTaskString = "by 11/11/2013 2359 hrs : action";
	EXPECT_EQ(expectedTaskString, task.formatTaskOutputString());
}

TEST(TaskTest, CheckingDeadlineTaskType){
	std::string action = "action";
	std::string location = "";
	Date startingDate;
	int startingTime = -1;
	Date endingDate;
	int endingTime = -1;
	Date deadlineDate(11,11,2013);
	int deadlineTime = 2359;
	bool block = false; 

	Task task(action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);
	EXPECT_EQ(true, task.isDeadlineType());
	EXPECT_EQ(false, task.isActivityType());
	EXPECT_EQ(false, task.isFloatingType());
}

TEST(TaskTest, CheckingActivityTaskType){
	std::string action = "action";
	std::string location = "";
	Date startingDate(11,11,2013);
	int startingTime = -1;
	Date endingDate(14,11,2013);
	int endingTime = -1;
	Date deadlineDate;
	int deadlineTime = -1;
	bool block = false; 

	Task task(action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);
	EXPECT_EQ(false, task.isDeadlineType());
	EXPECT_EQ(true, task.isActivityType());
	EXPECT_EQ(false, task.isFloatingType());
}

TEST(TaskTest, CheckingFloatingTaskType){
	std::string action = "action";
	std::string location = "location";
	Date startingDate;
	int startingTime = -1;
	Date endingDate;
	int endingTime = -1;
	Date deadlineDate;
	int deadlineTime = -1;
	bool block = false; 

	Task task(action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);
	EXPECT_EQ(false, task.isDeadlineType());
	EXPECT_EQ(false, task.isActivityType());
	EXPECT_EQ(true, task.isFloatingType());
}

TEST(TaskTest, EditingBlock){
	std::string action = "action";
	std::string location = "";
	Date startingDate;
	int startingTime = -1;
	Date endingDate;
	int endingTime = -1;
	Date deadlineDate(11,11,2013);
	int deadlineTime = 2359;
	bool block = false; 

	Task task(action, location, startingDate, startingTime, endingDate, endingTime, deadlineDate, deadlineTime, block);
	task.setBlock(true);
	EXPECT_EQ(true, task.getBlock());
	std::string newExpectedOutputString = "by 11/11/2013 2359 hrs : action (blockoff)";
	EXPECT_EQ(newExpectedOutputString, task.formatTaskOutputString());
}
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\TaskTest.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\TaskTest.h
	 */

#include <gtest\gtest.h>
#include <Task.h>
#include <Date.h>

class TaskTest : public ::testing::Test {
protected:
	TaskTest(){
	}

	virtual ~TaskTest(){
	}
	

	virtual void SetUp(){
	
	}

	Task task;
};


	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\TaskTest.h





