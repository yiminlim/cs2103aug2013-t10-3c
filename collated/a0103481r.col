//@author: a0103481r



	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\DoneLinkedList.cpp
	 */

#include "DoneLinkedList.h"

const std::string DoneLinkedList::KEYWORD_EMPTY_STRING = "";

DoneLinkedList::DoneLinkedList(){
	_head = NULL;
	_size = 0;
}
	
//Destructor for linked list
DoneLinkedList::~DoneLinkedList(){
}

//Pre-condition: Input an index between the range of 1 and the size of the linked list (including).
//Post-condition: Return a ListNode pointer that will traverse to the position given by the index.
DoneLinkedList::ListNode* DoneLinkedList::traverseTo(int index){
	if ( (index < 1) || (index > getSize()) ){
		return NULL;
	}else{
		ListNode *cur = _head;
		for (int skip = 1; skip < index; skip++){
			cur = cur->next;
		}
		return cur;
	}
}
	
//Pre-condition: Check if linked list is empty.
//Post-condition: Return true if the linked list is empty.
bool DoneLinkedList::isEmpty(){
	return _size == 0;
}
	
//Pre-condition: Check for the size of the linked list.
//Post-condition: Return the number of tasks in the linked list.
int DoneLinkedList::getSize(){
	return _size;
}

//Pre-condition: Input a Date input and an empty Date date and copy the input into the date.
//Post-condition: The date now contains the same values as the input.
void DoneLinkedList::obtainDateSeparately(Date *inputDate, Date *date){
	date->_day = inputDate->_day;
	date->_month = inputDate->_month;
	date->_year = inputDate->_year;
}

//Pre-condition: Input in a Task reference and fours pointers indicating date and time and ending date and time.
//				 For empty time, it is declared with a value -1.
//				 For empty Date, it is declared as 0.
//Post-condition: The pointer indicating date and time will be updated to store either the startingDate and startingTime or the deadlineDate and deadlineTime of the respective Task. 
//				  The pointer indicating endDate and endTime will be updated to store the endingDate and endingDate if it has one. Else, store them as 0 and -1.
void DoneLinkedList::obtainDateAndTime(Task & task, Date *date, int *time, Date *endDate, int *endTime){
	if (task.getDeadlineDate()._day == 0){
		obtainDateSeparately(&task.getStartingDate(), date);
		*time = task.getStartingTime();
		obtainDateSeparately(&task.getEndingDate(), endDate);
		*endTime = task.getEndingTime();
	}else{
		obtainDateSeparately(&task.getDeadlineDate(), date);
		*time = task.getDeadlineTime();
		*endTime = -1;
	}
	return;
}

//Pre-condition: Input 2 dates and a bool check to compare the 2 dates. If both dates are the same, return check as true.
//Post-condition: Return true if the curDate is earlier than the listDate. If there is no difference, the bool check is updated as true and it returns false.
bool DoneLinkedList::compareDates(Date *curDate, Date *listDate, bool *check){
		if (curDate->_year < listDate->_year){
			return true;
		}else if (curDate->_year > listDate->_year){
			return false;
		}else if (curDate->_month < listDate->_month){
			return true;
		}else if (curDate->_month > listDate->_month){
			return false;
		}else if (curDate->_day < listDate->_day){
			return true;
		}else if (curDate->_day > listDate->_day){
			return false;
		}else{
			*check = true;
			return false;
		}
}

//Pre-condition: Input the Task reference to be added and a specific Task reference from the linked list and sort them accordingly.
//Post-condition: Return true if the Task reference to be added is of an earlier date and time than the specific Task reference from the linked list.
bool DoneLinkedList::compareDateAndTime(Task & curTask, Task & listTask){
		Date *curDate = new Date;
		Date *listDate = new Date;
		Date *endListDate = new Date;
		Date *endCurDate = new Date;
		int *curTime = new int, *listTime = new int, *endCurTime = new int, *endListTime = new int;
		bool condition = false, check = false;
		obtainDateAndTime(curTask, curDate, curTime, endCurDate, endCurTime);
		obtainDateAndTime(listTask, listDate, listTime, endListDate, endListTime);

		condition = compareDates(curDate, listDate, &check);
		if (check){
			if (*curTime < *listTime){
				condition = true;
			}else if (*curTime == *listTime){
				if (*curTime == -1){
					condition = true;
				}else{
					check = false;
					condition = compareDates(endCurDate, endListDate, &check);
					if (check){
						if (*endCurTime < *endListTime){
							condition = true;
						}else{
							condition = false;
						}
					}
				}
			}else if(*curTime > *listTime){
				condition = false;
				}
		}

		delete curDate;
		curDate = NULL;
		delete listDate;
		listDate = NULL;
		delete curTime;
		curTime = NULL;
		delete listTime;
		listTime = NULL;
		delete endCurDate;
		endCurDate = NULL;
		delete endListDate;
		endListDate = NULL;
		delete endCurTime;
		endCurTime = NULL;
		delete endListTime;
		endListTime = NULL;

		return condition;		
}

//Pre-condition: Input a Task reference to check for the index which it should be inserted into the linked list, in a sorted manner.
//Post-condition: Return the index where the Task is supposed to be added at.
int DoneLinkedList::getInsertIndex(Task & curTask){
	ListNode *cur = _head;
	int i = 1;

	if (isEmpty()){
		return i;
	}

	while (cur != NULL){
		if (compareDateAndTime(curTask, cur->item)){
			return i;
		}else{
			cur = cur->next;
			i++;
		}
	} 

	return i;
}

//Pre-condition: Input a Task reference to be added into the linked list.
//Post-condition: Return true if the task is added into the linked list in an sorted manner.
bool DoneLinkedList::insert(Task & curTask){
	assert (curTask.getTask() != KEYWORD_EMPTY_STRING);
	int newSize = getSize() + 1;
	int index = getInsertIndex(curTask);

	if ( (index < 1) || (index > newSize) ){
		return false;
	}else{
		ListNode *newTask = new ListNode;
		newTask->item = curTask;
		newTask->next = NULL;
		_size = newSize;

		if (index == 1){
			newTask->next = _head;
			_head = newTask;
		}else{
			ListNode *prev = traverseTo(index-1);
			newTask->next = prev->next;
			prev->next = newTask;
		}
	}
	return true;
}

//Pre-condition: Input a task and obtain the necessary date (starting, ending or deadline) and update accordingly.
//Post-condition: The required date is obtained and updated accordingly.
void DoneLinkedList::obtainDateAndTimeForRemoving(Task & task, Date *date, int *time){
	if (task.getDeadlineDate()._day != 0){
		obtainDateSeparately(&task.getDeadlineDate(), date);
		*time = task.getDeadlineTime();
	}else if (task.getStartingDate()._day != 0 && task.getEndingDate()._day == 0){
		obtainDateSeparately(&task.getStartingDate(), date);
		*time = task.getStartingTime();
	}else if (task.getStartingDate()._day != 0 && task.getEndingDate()._day != 0){
		obtainDateSeparately(&task.getEndingDate(), date);
		*time = task.getEndingTime();
	}
	return;
}

//Pre-condition: Input a date today and compare with the dates in the linked list and for dates which are earlier than today, the index of the task is pushed into the vector.
//Post-condition: Return a vector of index that contains tasks with dates that are earlier than today.
std::vector<int> DoneLinkedList::getIndex(Date today){
	ListNode *cur = _head;
	std::vector <int> index; 
	int i = 1;
	Date *date = new Date;
	int *time = new int;
	
	while(cur != NULL){
		obtainDateAndTimeForRemoving(cur->item, date, time);
		if (today._year > date->_year){
			index.push_back(i);
		}else if (today._year == date->_year){
			if (today._month > date->_month){
				index.push_back(i);
			}else if (today._month == date->_month){
				if (today._day > date->_day){
					index.push_back(i);
				}
			}
		}
		cur = cur->next;
		i++;
	}

	delete cur;
	cur = NULL;
	delete date;
	date = NULL;
	delete time;
	time = NULL;

	return index;
}

//Pre-condition: Input an index and remove the task from the linked list which the index points to.
//Post-condition: Task pointed by the index is deleted.
void DoneLinkedList::remove(int index){
	assert (index > 0 && index < getSize()+1);
	ListNode *cur;
	--_size;

	if (index == 1){
		cur = _head;
		_head = _head->next;
	}else{
		ListNode *prev = traverseTo(index - 1);
		cur = prev->next;
		prev->next = cur->next;
	}
	delete cur;
	cur = NULL;
}

//Pre-condition: Input a Task reference to be deleted from the linked list. 
//Post-condition: Return true if the task is deleted from the linked list.
bool DoneLinkedList::removeTask(std::string task){
	ListNode *cur = _head;
	int index = 1;
	
	while (cur != NULL){
		if (task == cur->item.getTask()){
			remove(index);
			return true;
		}else{
			cur = cur->next;
			index++;
		}
	}
	return false;
}

//Pre-condition: Input a Date today that stores day, month and year individully as integers and update the linked list such that tasks before this date are all removed.
//Post-condition: Linked list do not contain any overdued done items in terms of date wise (not timewise).
void DoneLinkedList::update(Date today){
	assert (today._day != 0 && today._month != 0 && today._year != 0);
	std::vector <int> index = getIndex(today);

	for(int i = index.size(); i > 0; i--){
		remove(index[i-1]);
	}
}

//Pre-condition: Input an empty vector and copy all the output format of the tasks in the linked list into this vector.
//Post-condition: The entire output format of the tasks in the linked list is copied over into the vector.
void DoneLinkedList::updateStorageVector(std::vector<std::string> & tbDoneVector){
	assert (tbDoneVector.empty());
	ListNode *cur = _head;

	while (cur != NULL){
		tbDoneVector.push_back(cur->item.getTask());
		cur = cur->next;
	}
}
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\DoneLinkedList.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\DoneLinkedList.h
	 */

#pragma once

#include "Task.h"
#include "Date.h"
#include <assert.h>

class DoneLinkedList{
private:
	struct ListNode {
		Task item;
		ListNode *next;
	};
	
	ListNode* _head;
	int _size;
	
	//Returns a ListNode pointer that will traverse to the position given by the index.
	ListNode* traverseTo(int index);
	
	static const std::string KEYWORD_EMPTY_STRING;

public:
	//Empty constructor
	DoneLinkedList();
	
	//Destructor for linked list
	~DoneLinkedList();
	
	//Return true if the linked list is empty.
	bool isEmpty();
	
	//Return number of tasks in linked list.
	int getSize();

	//Copy the Date from one Date to another.
	void obtainDateSeparately(Date*, Date*);

	//Determine if the task has a starting date and time or deadline date and time and pass back the one with the value. Also, update the ending date and time accordingly.
	void obtainDateAndTime(Task &, Date*, int*, Date*, int*);

	//Compare the 2 dates and return true is one of the date is earlier than the other one. If they are the same, updated the bool value passed into the function.
	bool compareDates(Date*, Date*, bool*);

	//Return true if the one task is of an earlier date and time than the other task.
	bool compareDateAndTime(Task &, Task &);

	//Return the index at which a Task is to be added.
	int getInsertIndex(Task &);
	
	//Return true if task is added to linked list.
	bool insert(Task &);

	//Determine which date to look at for updating (starting, ending or deadline) and pass the selected one over.
	void obtainDateAndTimeForRemoving(Task &, Date*, int*);

	//Return a vector of index which indicates the tasks to be deleted.
	std::vector <int> getIndex(Date);

	//Remove the task pointed to by the index.
	void remove(int);

	//Return true if the task passed over is found and removed from the linked list.
	bool removeTask(std::string);

	//Update the linked list such that it does not contain overdued due items.
	void update(Date);

	//Return everything in the linked list.
	void updateStorageVector(std::vector<std::string> &);
};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\DoneLinkedList.h





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\OverdueLinkedList.cpp
	 */

#include "OverdueLinkedList.h"

const std::string OverdueLinkedList::KEYWORD_EMPTY_STRING = "";

OverdueLinkedList::OverdueLinkedList(){
	_head = NULL;
	_size = 0;
}
	
//Destructor for linked list
OverdueLinkedList::~OverdueLinkedList(){
}

//Pre-condition: Input an index between the range of 1 and the size of the linked list (including).
//Post-condition: Return a ListNode pointer that will traverse to the position given by the index.
OverdueLinkedList::ListNode* OverdueLinkedList::traverseTo(int index){
	if ( (index < 1) || (index > getSize()) ){
		return NULL;
	}else{
		ListNode *cur = _head;
		for (int skip = 1; skip < index; skip++){
			cur = cur->next;
		}
		return cur;
	}
}

//Pre-condition: Check if linked list is empty.
//Post-condition: Return true if the linked list is empty.
bool OverdueLinkedList::isEmpty(){
	return _size == 0;
}
	
//Pre-condition: Check for the size of the linked list.
//Post-condition: Return the number of tasks in the linked list.
int OverdueLinkedList::getSize(){
	return _size;
}

//Pre-condition: Input a Date input and an empty Date date and copy the input into the date.
//Post-condition: The date now contains the same values as the input.
void OverdueLinkedList::obtainDateSeparately(Date *inputDate, Date *date){
	date->_day = inputDate->_day;
	date->_month = inputDate->_month;
	date->_year = inputDate->_year;
}

//Pre-condition: Input in a Task reference and fours pointers indicating date and time and ending date and time.
//				 For empty time, it is declared with a value -1.
//				 For empty Date, it is declared as 0.
//Post-condition: The pointer indicating date and time will be updated to store either the startingDate and startingTime or the deadlineDate and deadlineTime of the respective Task. 
//				  The pointer indicating endDate and endTime will be updated to store the endingDate and endingDate if it has one. Else, store them as 0 and -1.
void OverdueLinkedList::obtainDateAndTime(Task & task, Date *date, int *time, Date *endDate, int *endTime){
	if (task.getDeadlineDate()._day == 0){
		obtainDateSeparately(&task.getStartingDate(), date);
		*time = task.getStartingTime();
		obtainDateSeparately(&task.getEndingDate(), endDate);
		*endTime = task.getEndingTime();
	}else{
		obtainDateSeparately(&task.getDeadlineDate(), date);
		*time = task.getDeadlineTime();
		*endTime = -1;
	}
	return;
}

//Pre-condition: Input 2 dates and a bool check to compare the 2 dates. If both dates are the same, return check as true.
//Post-condition: Return true if the curDate is earlier than the listDate. If there is no difference, the bool check is updated as true and it returns false.
bool OverdueLinkedList::compareDates(Date *curDate, Date *listDate, bool *check){
		if (curDate->_year < listDate->_year){
			return true;
		} else if (curDate->_year > listDate->_year){
			return false;
		} else if (curDate->_month < listDate->_month){
			return true;
		} else if (curDate->_month > listDate->_month){
			return false;
		} else if (curDate->_day < listDate->_day){
			return true;
		} else if (curDate->_day > listDate->_day){
			return false;
		}else{
			*check = true;
			return false;
		}
}

//Pre-condition: Input the Task reference to be added and a specific Task reference from the linked list and sort them accordingly.
//Post-condition: Return true if the Task reference to be added is of an earlier date and time than the specific Task reference from the linked list.
bool OverdueLinkedList::compareDateAndTime(Task & curTask, Task & listTask){
		Date *curDate = new Date;
		Date *listDate = new Date;
		Date *endListDate = new Date;
		Date *endCurDate = new Date;
		int *curTime = new int, *listTime = new int, *endCurTime = new int, *endListTime = new int;
		bool condition = false, check=false;
		obtainDateAndTime(curTask, curDate, curTime, endCurDate, endCurTime);
		obtainDateAndTime(listTask, listDate, listTime, endListDate, endListTime);

		condition = compareDates(curDate, listDate, &check);
		if (check){
			if (*curTime < *listTime){
				condition = true;
			}else if (*curTime == *listTime){
				if (*curTime == -1){
					condition = true;
				}else{
					check = false;
					condition = compareDates(endCurDate, endListDate, &check);
					if (check){
						if (*endCurTime < *endListTime){
							condition = true;
						}else{
							condition = false;
						}
					}
				}
			}else if(*curTime > *listTime){
				condition = false;
				}
		}

		delete curDate;
		curDate = NULL;
		delete listDate;
		listDate = NULL;
		delete curTime;
		curTime = NULL;
		delete listTime;
		listTime = NULL;
		delete endCurDate;
		endCurDate = NULL;
		delete endListDate;
		endListDate = NULL;
		delete endCurTime;
		endCurTime = NULL;
		delete endListTime;
		endListTime = NULL;

		return condition;		
}

//Pre-condition: Input a Task reference to check for the index which it should be inserted into the linked list, in a sorted manner.
//Post-condition: Return the index where the Task is supposed to be added at.
int OverdueLinkedList::getInsertIndex(Task & curTask){
	ListNode *cur = _head;
	int i = 1;

	if (isEmpty()){
		return i;
	}

	while (cur != NULL){
		if (compareDateAndTime(curTask, cur->item)){
			return i;
		}else{
			cur = cur->next;
			i++;
		}
	} 

	return i;
}

//Pre-condition: Input a Task reference to be added into the linked list. 
//Post-condition: Return true if the task is added into the linked list in an sorted manner.
bool OverdueLinkedList::insert(Task & curTask){
	assert (curTask.getTask() != KEYWORD_EMPTY_STRING);
	int newSize = getSize() + 1;
	int index = getInsertIndex(curTask);

	if ( (index < 1) || (index > newSize) ){
		return false;
	}
	else{
		ListNode *newTask = new ListNode;
		newTask->item = curTask;
		newTask->next = NULL;
		_size = newSize;

		if (index == 1){
			newTask->next = _head;
			_head = newTask;
		}else{
			ListNode *prev = traverseTo(index-1);
			newTask->next = prev->next;
			prev->next = newTask;
		}
	}
	return true;
}

//Pre-condition: Call this function to remove the first item in the linked list.
//Post-condition: Head of the linked list is removed.
void OverdueLinkedList::remove(){
	ListNode *cur;
	--_size;

	cur = _head;
	_head = _head->next;
 
	delete cur;
	cur = NULL;
}

//Pre-condition: Call this function to clear the entire linked list.
//Post-condition: Entire linked list is removed.
void OverdueLinkedList::clear(){
	while (!isEmpty()){
		remove();
	}
}

//Pre-condition: Input an empty vector to retrieve alll the items in the linked list.
//Post-condition: Return a vector containing all the items in the linked list.
void OverdueLinkedList::updateStorageVector(std::vector<std::string> & tbOverdueVector){
	assert (tbOverdueVector.empty());
	ListNode *cur = _head;

	while (cur != NULL){
		tbOverdueVector.push_back(cur->item.getTask());
		cur = cur->next;
	}
}
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\OverdueLinkedList.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\OverdueLinkedList.h
	 */

#pragma once

#include "Task.h"
#include "Date.h"
#include <assert.h>

class OverdueLinkedList{
private:
	struct ListNode {
		Task item;
		ListNode *next;
	};
	
	ListNode* _head;
	int _size;

	//Return a ListNode pointer that will traverse to the position given by the index.
	ListNode* traverseTo(int index);

	static const std::string KEYWORD_EMPTY_STRING;
	
public:
	//Empty constructor
	OverdueLinkedList();
	
	//Destructor for linked list
	~OverdueLinkedList();
	
	//Return true if the linked list is empty.
	bool isEmpty();
	
	//Return number of tasks in linked list.
	int getSize();

	//Copy the Date from one Date to another.
	void obtainDateSeparately(Date*, Date*);

	//Determine if the task has a starting date and time or deadline date and time and pass back the one with the value. Also, update the ending date and time accordingly.
	void obtainDateAndTime(Task &, Date*, int*, Date*, int*);

	//Compare the 2 dates and return true is one of the date is earlier than the other one. If they are the same, updated the bool value passed into the function.
	bool compareDates(Date*, Date*, bool*);

	//Return true if the one task is of an earlier date and time than the other task.
	bool compareDateAndTime(Task &, Task &);

	//Return the index at which a Task is to be added.
	int getInsertIndex(Task &);
	
	//Return true if task is added to linked list.
	bool insert(Task &);

	//Remove the item at the head of the linked list.
	void remove();

	//Remove all the items in the linked list.
	void clear();
	
	//Retrieve all the items in the linked list.
	void updateStorageVector(std::vector<std::string> &);
};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\OverdueLinkedList.h





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\TaskLinkedList.cpp
	 */

#include "TaskLinkedList.h"

const std::string TaskLinkedList::KEYWORD_EMPTY_STRING = "";
const std::string TaskLinkedList::KEYWORD_BLOCKOFF = "blockoff";
const std::string TaskLinkedList::KEYWORD_ZERO = "0";
const std::string TaskLinkedList::KEYWORD_SLASH = "/";
const std::string TaskLinkedList::KEYWORD_DASH = "-";

const char TaskLinkedList::KEYWORD_NULL = '\0';

const int TaskLinkedList::KEYNUMBER_DAY = 31;
const int TaskLinkedList::KEYNUMBER_MONTH = 12;

TaskLinkedList::TaskLinkedList(){
	_head = NULL;
	_size = 0;
}
	
//Destructor for linked list
TaskLinkedList::~TaskLinkedList(){
}

//Pre-condition: Input an index between the range of 1 and the size of the linked list (including).
//Post-condition: Return a ListNode pointer that will traverse to the position given by the index.
TaskLinkedList::ListNode* TaskLinkedList::traverseTo(int index){
	if ( (index < 1) || (index > getSize()) ){
		return NULL;
	}else{
		ListNode *cur = _head;
		for (int skip = 1; skip < index; skip++){
			cur = cur->next;
		}
		return cur;
	}
}
	
//Pre-condition: Check if linked list is empty.
//Post-condition: Return true if the linked list is empty.
bool TaskLinkedList::isEmpty(){
	return _size == 0;
}
	
//Pre-condition: Check for the size of the linked list.
//Post-condition: Return the number of tasks in the linked list.
int TaskLinkedList::getSize(){
	return _size;
}

//Pre-condition: Input a Date input and an empty Date date and copy the input into the date.
//Post-condition: The date now contains the same values as the input.
void TaskLinkedList::obtainDateSeparately(Date *inputDate, Date *date){
	date->_day = inputDate->_day;
	date->_month = inputDate->_month;
	date->_year = inputDate->_year;
}

//Pre-condition: Input in a Task reference and fours pointers indicating date and time and ending date and time.
//				 For empty time, it is declared with a value -1.
//				 For empty Date, it is declared as 0.
//Post-condition: The pointer indicating date and time will be updated to store either the startingDate and startingTime or the deadlineDate and deadlineTime of the respective Task. 
//				  The pointer indicating endDate and endTime will be updated to store the endingDate and endingDate if it has one. Else, store them as 0 and -1.
void TaskLinkedList::obtainDateAndTime(Task & task, Date *date, int *time, Date *endDate, int *endTime){
	if (task.getDeadlineDate()._day == 0){
		obtainDateSeparately(&task.getStartingDate(), date);
		*time = task.getStartingTime();
		obtainDateSeparately(&task.getEndingDate(), endDate);
		*endTime = task.getEndingTime();
	}else{
		obtainDateSeparately(&task.getDeadlineDate(), date);
		*time = task.getDeadlineTime();
		*endTime = -1;
	}

	return;
}

//Pre-condition: Input 2 dates and a bool check to compare the 2 dates. If both dates are the same, return check as true.
//Post-condition: Return true if the curDate is earlier than the listDate. If there is no difference, the bool check is updated as true and it returns false.
bool TaskLinkedList::compareDates(Date *curDate, Date *listDate, bool *check){
		if (curDate->_year < listDate->_year){
			return true;
		}else if (curDate->_year > listDate->_year){
			return false;
		}else if (curDate->_month < listDate->_month){
			return true;
		}else if (curDate->_month > listDate->_month){
			return false;
		}else if (curDate->_day < listDate->_day){
			return true;
		}else if (curDate->_day > listDate->_day){
			return false;
		}else{
			*check = true;
			return false;
		}
}

//Pre-condition: Input the Task reference to be added and a specific Task reference from the linked list and sort them accordingly. Check along the way if there are any clashes.
//Post-condition: Return true if the Task reference to be added is of an earlier date and time than the specific Task reference from the linked list. Update isClash accordingly and return a vector of task that clashes.
bool TaskLinkedList::compareDateAndTime(Task & curTask, Task & listTask, bool & isClash, std::vector<std::string>& clashTasks){
		Date *curDate = new Date;
		Date *listDate = new Date;
		Date *endListDate = new Date;
		Date *endCurDate = new Date;
		int *curTime = new int, *listTime = new int, *endCurTime = new int, *endListTime = new int;
		bool condition = false, check = false;
		obtainDateAndTime(curTask, curDate, curTime, endCurDate, endCurTime);
		obtainDateAndTime(listTask, listDate, listTime, endListDate, endListTime);

		condition = compareDates(curDate, listDate, &check);
		if (check){
			if (*curTime < *listTime){
				condition = true;
				if ( (*endListTime == -1 && *endCurTime != -1 && curDate->_day != 0 && listDate->_day != 0) || (*endListTime != -1 && *endCurTime != -1 && curDate->_day != 0 && listDate->_day != 0) ){ //both from to
					if (*endCurTime > *listTime){
						isClash = true; //cur is from to, list is from
						clashTasks.push_back(listTask.getTask());
					}
				}
			}else if (*curTime == *listTime && *curTime != -1){
				isClash = true; //both froms
				clashTasks.push_back(listTask.getTask());
				
				check = false;
				condition = compareDates(endCurDate, endListDate, &check);
				if (check){
					if (*endCurTime < *endListTime){
						condition = true;
					}else{
						condition = false;
					}
				}
			}else if (*curTime > *listTime){
				condition = false; 
				if ( (*endCurTime == -1 && *endListTime != -1 && curDate->_day != 0 && listDate->_day != 0) || (*endListTime != -1 && *endCurTime != -1 && curDate->_day != 0 && listDate->_day != 0) ){ //both from to
					if (*endListTime > *curTime){
						isClash = true; //cur is from, list is from to
						clashTasks.push_back(listTask.getTask());
					}	
				}
			}
		}

		delete curDate;
		curDate = NULL;
		delete listDate;
		listDate = NULL;
		delete curTime;
		curTime = NULL;
		delete listTime;
		listTime = NULL;
		delete endCurTime;
		endCurTime = NULL;
		delete endListTime;
		endListTime = NULL;
		delete endCurDate;
		endCurDate = NULL;
		delete endListDate;
		endListDate = NULL;

		return condition;		
}

//Pre-condition: Input a Task reference to check for the index which it should be inserted into the linked list, in a sorted manner. Also, check for clashes throughout the linked list.
//Post-condition: Return the index where the Task is supposed to be added at. Update isClash accordingly and return a vector of task that clashes.
int TaskLinkedList::getInsertIndex(Task & curTask, bool & isClash, std::vector<std::string>& clashTasks){
	ListNode *cur = _head;
	int i = 1;
	bool dummy;

	if (isEmpty()){
		return i;
	}

	while (cur != NULL){
		if (compareDateAndTime(curTask, cur->item, isClash, clashTasks)){
			if (isClash){
				cur = cur->next;
				while (cur != NULL){
					dummy = compareDateAndTime(curTask, cur->item, isClash, clashTasks);
					cur = cur->next;
				}
				return i;
			}else{
				return i;
			}
		}else{
			cur = cur->next;
			i++;
		}
	} 
	return i;
}

//Pre-condition: Input a Task reference to be added into the linked list, check if any task clashes and update isClash to be true if it does and return the vector of tasks that clash.
//				 isClash has to be false when it is passed over.
//				 clashTasks must be empty.
//Post-condition: Return true if the task is added into the linked list in a sorted manner. isClash and clashTasks are updated accordingly.
bool TaskLinkedList::insert(Task & curTask, bool & isClash, std::vector<std::string>& clashTasks){
	assert(curTask.getTask() != KEYWORD_EMPTY_STRING);
	assert(!isClash);
	int newSize = getSize() + 1;
	int index = getInsertIndex(curTask, isClash, clashTasks);

	if ( (index < 1) || (index > newSize) ){
		return false;
	}else{
		ListNode *newTask = new ListNode;
		newTask->item = curTask;
		newTask->next = NULL;
		_size = newSize;

		if (index == 1){
			newTask->next = _head;
			_head = newTask;
		}else{
			ListNode *prev = traverseTo(index-1);
			newTask->next = prev->next;
			prev->next = newTask;
		}
	}
	return true;
}

//Pre-condition: Input a string containing the output format of the task to be deleted from the linked list and a pointer indicating the index, search for the task in the linked list and obtain the index of the task.
//Post-condition: Return true if task is found in the linked list and the index pointer will be updated accordingly.
bool TaskLinkedList::getRemoveIndex(std::string task, int *index){
	assert(*index == 1);
	ListNode *cur = _head;

	while (cur->item.getTask() != task && cur != NULL){
		cur = cur->next;
		(*index)++;
	}

	if (cur != NULL){
		return true; 
	}

	return false;
}

//Pre-condition: Input a line and an empty vector to contain keywords.
//Post-condition: Split the line into individual words and store them in the keywords vector.
void TaskLinkedList::splitIntoKeywords(std::string line, std::vector<std::string> & keywords){
	assert(keywords.empty());
	std::stringstream iss;
	std::string keyword;
	iss << line;

	while (iss >> keyword){
		keywords.push_back(keyword);
	}
}

//Pre-condition: Input a string containing a line of action and location and check if there is only one block off task having this action and location left. If yes, the last block off task will be unblocked.
//			     The last task must contain the word "blockoff" in the output format.
//Post-condition: If there is only one task left in a specific block, unblock the task accordingly.
void TaskLinkedList::checkIfRemainingBlockTask(std::string line){
	std::vector<std::string> keywords;
	std::vector<std::string> taskList;
	int *index = new int;
	*index = 1;
	ListNode *cur = _head;
	splitIntoKeywords(line, keywords);
	keywords.push_back(KEYWORD_BLOCKOFF);

	if (retrieve(keywords, taskList)){
		if (taskList.size() == 1){
			if (getRemoveIndex(taskList[0], index)){
				cur = traverseTo(*index);
				cur->item.setBlock(false);
			}
		}
	}

	delete index;
	index = NULL;
}

//Pre-condition: Input a string containing the output format of the task to be deleted from the linked list and a line containing the action and location to cater in the fact that if there's only one task block remaining, it will be unblocked.
//Post-condition: Return true if the task is found and deleted from the linked list, if task comes from a block, the last block will be unblocked.
bool TaskLinkedList::remove(std::string task, std::string line){
	assert(task != KEYWORD_EMPTY_STRING);
	int *index = new int;
	*index = 1;
	bool condition = false;
	if (getRemoveIndex(task, index)){
		ListNode *cur;
		--_size;

		if (*index == 1){
			cur = _head;
			_head = _head->next;
		}else{
			ListNode *prev = traverseTo(*index-1);
			cur = prev->next;
			prev->next = cur->next;
		}
		delete cur;
		cur = NULL;
		condition = true;
	}

	checkIfRemainingBlockTask(line);
	
	delete index;
	index = NULL;
	return condition;
}

//Pre-condition: Input a string of words/word and convert it to lower case.
//Post-condition: Return the same string but converted to lower case.
std::string TaskLinkedList::toLowerCase(std::string line){
	for (unsigned int i = 0; line[i] != KEYWORD_NULL; i++){
		line[i] = tolower(line[i]);
	}
	return line;
}

//Pre-condition:Input day, month and year in int and convert them into a string in this format dd/mm/yy.
//			    Day and month have to be greater than 0. While year is at least 4 digits (the first digit is not 0).
//Post-condtion: Return a string date form from individual int day, month, year.
std::string TaskLinkedList::getStringDate(int day, int month, int year){
	assert(day > 0 && month > 0);
	std::ostringstream output;
	
	if (day < 10){
		output << KEYWORD_ZERO << day << KEYWORD_SLASH;
	}else{
		output << day << KEYWORD_SLASH;
	}

	if (month < 10){
		output << KEYWORD_ZERO << month << KEYWORD_SLASH << year;
	}else{
		output << month << KEYWORD_SLASH << year;
	}

	return output.str();
}

//Pre-condition: Input a tempTask and the starting and ending dates and push in the dates that are within the range of the starting and ending dates.
//				 Consider the maximum number of days to be 31 for all cases.
//Post-condition: Return a tempTask with the range of dates added at the back.
std::string TaskLinkedList::compareAndIncludeRange(std::string tempTask, int *startDay, int *startMonth, int *startYear, int *endDay, int *endMonth, int *endYear){
	int i, j, k;

	if (*startYear != *endYear){
		for (i = *startYear; i < *endYear; i++){
			for (j = 1; j <= KEYNUMBER_MONTH; j++){
				if (i == *startYear && j == 1){
					j = *startMonth;
				}
				for (k = 1; k <= KEYNUMBER_DAY; k++){
					if (j == *startMonth && k == 1){
						k = *startDay;
					}
					tempTask = tempTask + getStringDate(k,j,i);
				}
			}
		}
		if (i == *endYear){
			for (j = 1; j <= *endMonth; j++){
				for (k = 1; k <= *endDay; k++){
					tempTask = tempTask + getStringDate(k,j,i);
				}
			}
		}
	}else if (*startMonth != *endMonth){
		i = *startYear;
		for (j = *startMonth; j < *endMonth; j++){
			for (k = 1; k <= KEYNUMBER_DAY; k++){
				if (j == *startMonth && k == 1){
					k = *startDay;
				}
				tempTask = tempTask + getStringDate(k, j, i);
			}
		}
		if (j == *endMonth){
			for (k = 1; k <= *endDay; k++){
				tempTask = tempTask + getStringDate(k,j,i);
			}
		}
	}else if (*startDay != *endDay){
		i = *startYear;
		j = *startMonth;
		for (k = *startDay; k <= *endDay; k++){
			tempTask = tempTask + getStringDate(k,j,i);
		}
	}

	return tempTask;
}

//Pre-condition: Input a string date and convert into individual day, month and year as integers.
//				 String must be in the format dd/mm/yyyy.
//Post-condition: Pointers are updated (day, month, year as int).
void TaskLinkedList::getIntDate(std::string date, int *day, int *month, int *year){
	size_t posFirstDateSeparator = date.find(KEYWORD_SLASH);
	size_t posSecondDateSeparator = date.find(KEYWORD_SLASH, posFirstDateSeparator+1);
	
	std::string sDay = date.substr(0, posFirstDateSeparator-0);
	std::string sMonth = date.substr(posFirstDateSeparator+1, posSecondDateSeparator-posFirstDateSeparator-1);
	std::string sYear = date.substr(posSecondDateSeparator+1);

	std::istringstream ss1(sDay);
	ss1 >> *day;
	std::istringstream ss2(sMonth);
	ss2 >> *month;
	std::istringstream ss3(sYear);
	ss3 >> *year;
}

//Pre-condition: Input a task in the output format and include the range of dates to the back of this string if it is a period type of task (range of dates or time).
//				 Only check for range of dates entered in proper date format dd/mm/yyyy (note that the first digit day and month must have 0 if they are single digits).
//Post-condition: Return a task in the output format and an extension of dates if it is a period type of task.
std::string TaskLinkedList::includeRangeOfDates(std::string tempTask){
	if ((tempTask).find(KEYWORD_DASH) != std::string::npos){
		std::vector<std::string> words;
		splitIntoKeywords(tempTask, words);
		int i = 0;

		int *startDay = new int, *startMonth = new int, *startYear = new int, *endDay = new int, *endMonth = new int, *endYear = new int;
		getIntDate(words[i], startDay, startMonth, startYear);

		while (words[i] != "-"){
			i++;
		}
		getIntDate(words[i+1], endDay, endMonth, endYear);

		tempTask = compareAndIncludeRange(tempTask, startDay, startMonth, startYear, endDay, endMonth, endYear);
	
		delete startDay;
		startDay = NULL;
		delete startMonth;
		startMonth = NULL;	
		delete startYear;
		startYear = NULL;
		delete endDay;
		endDay = NULL;
		delete endMonth;
		endMonth = NULL;
		delete endYear;
		endYear = NULL;
	}

	return tempTask;
}
	
//Pre-condition: Input a vector of individual keywords and an empty vector of taskList to store the task that are found from the linked list which contains all of the keywords. 
//				 Check for the range in dates for period type of task as well.
//				 Will only take into consideration range in dates if the user inputs the date in the right format or uses words like today, tmr,.. (dd/mm/yyyy).
//Post-condition: Return true if at least 1 task is found to contain all of the keywords from the vector and updates the taskList vector accordingly.
bool TaskLinkedList::retrieve(const std::vector<std::string> keywords, std::vector<std::string> & taskList){
	assert(taskList.empty());
	ListNode *cur = _head;

	while (cur != NULL){
		int count = 0;
		for (unsigned int i = 0; i < keywords.size(); i++){
			std::string tempTask = toLowerCase(cur->item.getTask());
			tempTask = includeRangeOfDates(tempTask);
			std::string tempKeyword = toLowerCase(keywords[i]);
			if ((tempTask).find(tempKeyword) != std::string::npos){
				count++;
			}
		}
		if (count == keywords.size()){
			taskList.push_back(cur->item.getTask());
		}
		cur = cur->next;
	}

	if (taskList.empty()){
		return false;
	}else{
		return true;
	}
}

//Pre-condition: Input an empty vector and copy all the output format of the tasks in the linked list into this vector.
//Post-condition: The entire output format of the tasks in the linked list is copied over into the vector.
void TaskLinkedList::updateStorageVector(std::vector<std::string> & tbVector){
	assert(tbVector.empty());
	ListNode *cur = _head;

	while (cur != NULL){
		tbVector.push_back(cur->item.getTask());
		cur = cur->next;
	}
}

//Pre-condition: Input a string task to be located and change it's bool block as true.
//				 The task must be found in the linked list to successfully change the block to true.
//Post-condition: The task passed in is set as true for it's bool block.
void TaskLinkedList::setBlock(std::string task){
	assert(task != KEYWORD_EMPTY_STRING);
	ListNode *cur = _head;

	while (cur != NULL){
		if (cur->item.getTask() == task){ 
			cur->item.setBlock(true);
			return;
		}else{
			cur = cur->next;
		}
	}
}

//Pre-condition: Input 2 dates and compare them to check which is earlier. For dates that are passed today's date, the task in the output format is pushed into the overdueList vector.
//Post-condition: If the date is found to be over today's date, the overdueList vector is updated accordingly. 
void TaskLinkedList::compareWithToday(Date today, Date date, std::string task, std::vector<std::string> & overdueList){
	if (date._year < today._year){
		if (date._year != 0){
			overdueList.push_back(task);
		}
	}else if(date._year == today._year){
		if(date._month < today._month){
			if (date._month != 0){
				overdueList.push_back(task);
			}
		}else if(date._month == today._month){
			if(date._day < today._day){
				if (date._day != 0){
					overdueList.push_back(task);
				}
			}
		}
	}
}

//Pre-condition: Input a today date and a vector of overduelist to compare the dates and store overdue task in taskLinkedList into overduelinkedlist instead.
//Post-condition: Overdue items from taskLinkedList are stored in the vector and returned.
void TaskLinkedList::getOverdueList(Date today, std::vector<std::string> & overdueList){
	ListNode *cur = _head;

	while (cur != NULL){
		if (cur->item.getDeadlineDate()._day == 0 && cur->item.getEndingDate()._day == 0){
			compareWithToday(today, cur->item.getStartingDate(), cur->item.getTask(), overdueList);
		}else if (cur->item.getDeadlineDate()._day == 0 && cur->item.getEndingDate()._day != 0){
			compareWithToday(today, cur->item.getEndingDate(), cur->item.getTask(), overdueList);
		}else if (cur->item.getStartingDate()._day == 0){
			compareWithToday(today, cur->item.getDeadlineDate(), cur->item.getTask(), overdueList);
		}

		cur = cur->next;
	}
}

//Pre-condition: Input an index to retrieve the block status of the task indicated by the index.
//Post-condition: Return the block status of the task indicated by the index.
bool TaskLinkedList::getBlockStatus(int index){
	ListNode *cur = traverseTo(index);
	return cur->item.getBlock();
}

//Pre-condition: Input a task and check if it is the last remaining task left.
//Post-condition: Return true if it is the last remaining task
bool TaskLinkedList::checkIfRemainingTask(std::string task){
	ListNode *cur = _head;

	while (cur != NULL){
		if (cur->item.getTask() == task){
			return true;
		}
		cur = cur->next;
	}
	
	return false;
}
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\TaskLinkedList.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\TaskLinkedList.h
	 */

#pragma once

#include "Task.h"
#include "Date.h"
#include <assert.h>

class TaskLinkedList{
private:
	struct ListNode {
		Task item;
		ListNode *next;
	};
	
	ListNode* _head;
	int _size;
	
	//Return a ListNode pointer that will traverse to the position given by the index.
	ListNode* traverseTo(int index);

	static const std::string KEYWORD_EMPTY_STRING;
	static const std::string KEYWORD_BLOCKOFF;
	static const std::string KEYWORD_ZERO;
	static const std::string KEYWORD_SLASH;
	static const std::string KEYWORD_DASH;
	
	static const char KEYWORD_NULL;
	
	static const int KEYNUMBER_DAY;
	static const int KEYNUMBER_MONTH;
	
public:
	//Empty constructor
	TaskLinkedList();
	
	//Destructor for linked list
	~TaskLinkedList();
	
	//Return true if the linked list is empty.
	bool isEmpty();
	
	//Return number of tasks in linked list.
	int getSize();

	//Copy the Date from one Date to another.
	void obtainDateSeparately(Date*, Date*);

	//Determine if the task has a starting date and time or deadline date and time and pass back the one with the value and update the ending date and time accordingly.
	void obtainDateAndTime(Task &, Date*, int*, Date*, int*);

	//Compare the 2 dates and return true is one of the date is earlier than the other one. If they are the same, updated the bool value passed into the function.
	bool compareDates(Date*, Date*, bool*);

	//Return true if the one task is of an earlier date and time than the other task and check for clashes in the meantime.
	bool compareDateAndTime(Task &, Task &, bool &, std::vector<std::string>&);

	//Return the index at which a Task is to be added.
	int getInsertIndex(Task &, bool &, std::vector<std::string>&);
	
	//Return true if task is added to linked list. Check if there are any clashes.
	bool insert(Task &, bool &, std::vector<std::string>&);

	//Return the index of the task to be removed.
	bool getRemoveIndex(std::string, int*);

	//Split a string into a vector of keywords.
	void splitIntoKeywords(std::string, std::vector<std::string> &);
	
	//Check if the task is a blocked item and if it is the last task left. If true, unblock the task.
	void checkIfRemainingBlockTask(std::string); 
	
	//Return true if task is remove from linked list, at the same time, if the deleted item is a blocked item, check if there is only one task left in that specific block. If true, unblock the last task.
	bool remove(std::string, std::string);

	//Convert string into lowercase.
	std::string toLowerCase(std::string);

	//Convert int to string for date.
	std::string getStringDate(int, int, int);

	//Compare the range of dates and add the range into the task output format.
	std::string compareAndIncludeRange(std::string, int*, int*, int*, int*, int*, int*);

	//Convert string to int for date.
	void getIntDate(std::string, int*, int*, int*);

	//"Main function" to call the other functions to assist in including range in dates into temptask for searching.
	std::string includeRangeOfDates(std::string);

	//Pass over a vector of keywords and search for task which contains all keywords and return them in the empty vector of string that is passed over.
	bool retrieve(const std::vector<std::string>, std::vector<std::string> &);

	//Copy the entire list of output format of the tasks in the linked list into the empty vector that is passed over.
	void updateStorageVector(std::vector<std::string> &);

	//Set the bool block component of the string as true.
	void setBlock(std::string);

	//Compare the date with today's date and push the task into the vector passed over if it is earlier than today's date.
	void compareWithToday(Date, Date, std::string, std::vector<std::string> &);

	//Return list of overdued items.
	void getOverdueList(Date, std::vector<std::string> &);
	
	//Return whether the task indicated by the index is blocked or not (For g-test).
	bool getBlockStatus(int index);

	//Return true if it is the last remaining task.
	bool checkIfRemainingTask(std::string);
};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\TaskBuddy\TaskLinkedList.h





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\DoneLinkedListTest.cpp
	 */

#include <gtest\gtest.h>
#include "DoneLinkedListTest.h"

/****************************
 TEST FOR INSERT FUNCTION
****************************/

//Check to see if the function copies the date from one Date class to another Date class correctly.
TEST(DoneLinkedListTest, InsertMinorFunction1) {
	DoneLinkedList doneList;
	Date inputDate(1, 2, 2013);
	Date date;

	doneList.obtainDateSeparately(&inputDate, &date);

	EXPECT_EQ(1, date._day);
	EXPECT_EQ(2, date._month);
	EXPECT_EQ(2013, date._year);
}

//Check to see if the function obtains the right date and time (either starting or deadline) and updates the ending date and time accordingly.
TEST(DoneLinkedListTest, InsertMinorFunction2) {
	DoneLinkedList doneList;

	Date tempDate1(1,2,2013), tempDate2(3,4,2013), tempDate3(5,6,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("lunch with mum", "techno", tempDate1, 1200, tempDate2, 1300, nullDate, -1, false);
	Task task3("lunch with mum", "techno", nullDate, -1, nullDate, -1, tempDate3, 1400, false);
	Date date, endDate;
	int time, endTime = -1;


	doneList.obtainDateAndTime(task1, &date, &time, &endDate, &endTime);
	EXPECT_EQ(1, date._day);
	EXPECT_EQ(1200, time);
	EXPECT_EQ(0, endDate._day);
	EXPECT_EQ(-1, endTime);
	
	doneList.obtainDateAndTime(task3, &date, &time, &endDate, &endTime);
	EXPECT_EQ(5, date._day);
	EXPECT_EQ(1400, time);
	EXPECT_EQ(0, endDate._day);
	EXPECT_EQ(-1, endTime);

	doneList.obtainDateAndTime(task2, &date, &time, &endDate, &endTime);
	EXPECT_EQ(1, date._day);
	EXPECT_EQ(1200, time);
	EXPECT_EQ(3, endDate._day);
	EXPECT_EQ(1300, endTime);
}

//Check to see if the comparing of 2 dates give the correct result (true if cur is earlier than list).
TEST(DoneLinkedListTest, InsertMinorFunction3) {
	DoneLinkedList doneList;
	Date curDate(1,2,2013), listDate(3,4,2013);
	bool check = false;
	
	EXPECT_EQ(true, doneList.compareDates(&curDate, &listDate, &check));
	EXPECT_EQ(false, check);

	EXPECT_EQ(false, doneList.compareDates(&listDate, &curDate, &check));
	EXPECT_EQ(false, check);

	EXPECT_EQ(false, doneList.compareDates(&curDate, &curDate, &check));
	EXPECT_EQ(true, check);
}

//Check to see if the comaring of 2 tasks give the correct result (meaning which task should be sorted in front of which task accordingly to date and time).
TEST(DoneLinkedListTest, InsertMinorFunction4) {
	DoneLinkedList doneList;
	Date tempDate1(1,2,2013), tempDate2(3,4,2013), tempDate3(5,6,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("lunch with mum", "techno", tempDate2, 1200, tempDate2, 1300, nullDate, -1, false);
	Task task3("lunch with mum", "techno", nullDate, -1, nullDate, -1, tempDate3, 1400, false);
	Task task4("lunch with mum", "techno", tempDate2, 1200, tempDate2, 1000, nullDate, -1, false);

	EXPECT_EQ(true, doneList.compareDateAndTime(task1, task2));
	EXPECT_EQ(false, doneList.compareDateAndTime(task2, task1));
	EXPECT_EQ(true, doneList.compareDateAndTime(task1, task3));
	EXPECT_EQ(false, doneList.compareDateAndTime(task2, task4));
}

//Check to see if function returns the correct index pointing to the task that is passed over.
TEST(DoneLinkedListTest, InsertMinorFunction5) {
	DoneLinkedList doneList;
	Date tempDate1(1,2,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);	
	EXPECT_EQ(1, doneList.getInsertIndex(task1));
}

//Check to see if the function inserts a task properly, sorted according to date and time.
TEST(DoneLinkedListTest, InsertFunction) {
	DoneLinkedList doneList;
	Date tempDate1(1,2,2013), tempDate2(3,4,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate2, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("dance lessons", "dance studio", tempDate1, 1500, tempDate2, 1800, nullDate, -1, false);
	Task task3("homework assignment 2", "", nullDate, -1, nullDate, -1, tempDate1, 2359, false);
	std::vector<std::string> listOfTasks;

	EXPECT_EQ(true, doneList.insert(task1));
	doneList.insert(task2);
	doneList.insert(task3);

	doneList.updateStorageVector(listOfTasks);
	EXPECT_EQ(task2.getTask(), listOfTasks[0]);
	EXPECT_EQ(task3.getTask(), listOfTasks[1]);
	EXPECT_EQ(task1.getTask(), listOfTasks[2]);
}

/****************************
 TEST FOR REMOVE FUNCTION
****************************/

//Check if the function updates the date and time according to the one that is required from comparing when deciding whether the task is overdued.
TEST(DoneLinkedListTest, RemoveMinorFunction1) {
	DoneLinkedList doneList;
	Date tempDate1(1,2,2013), tempDate2(3,4,2013), nullDate, date;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("dance lessons", "dance studio", tempDate1, 1500, tempDate2, 1800, nullDate, -1, false);
	Task task3("homework assignment 2", "", nullDate, -1, nullDate, -1, tempDate2, 2359, false);
	int time;

	doneList.obtainDateAndTimeForRemoving(task1, &date, &time);
	EXPECT_EQ(tempDate1._day, date._day);
	EXPECT_EQ(1200, time);

	doneList.obtainDateAndTimeForRemoving(task2, &date, &time);
	EXPECT_EQ(tempDate2._day, date._day);
	EXPECT_EQ(1800, time);

	doneList.obtainDateAndTimeForRemoving(task3, &date, &time);
	EXPECT_EQ(tempDate2._day, date._day);
	EXPECT_EQ(2359, time);
}

//Check if the function returns a vector of index pointing to overdued tasks.
TEST(DoneLinkedListTest, RemoveMinorFunction2) {
	DoneLinkedList doneList;
	Date tempDate1(1,2,2013), tempDate2(3,2,2013), nullDate, today(2,2,2013);
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("dance lessons", "dance studio", tempDate1, 1500, tempDate2, 1800, nullDate, -1, false);
	Task task3("homework assignment 2", "", nullDate, -1, nullDate, -1, tempDate1, 2359, false);
	std::vector<int> index;

	doneList.insert(task1);
	doneList.insert(task2);
	doneList.insert(task3);
	index = doneList.getIndex(today);
	EXPECT_EQ(2, index.size());
	EXPECT_EQ(1, index[0]);
	EXPECT_EQ(3, index[1]);
}

//Check if the function removes a task properly according to the input index.
TEST(DoneLinkedListTest, RemoveFunctionByIndex) {
	DoneLinkedList doneList;
	Date tempDate1(1,2,2013), tempDate2(3,4,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("dance lessons", "dance studio", tempDate1, 1500, tempDate2, 1800, nullDate, -1, false);
	Task task3("homework assignment 2", "", nullDate, -1, nullDate, -1, tempDate1, 1600, false);
	std::vector<std::string> listOfTasks;

	doneList.insert(task1);
	doneList.insert(task2);
	doneList.insert(task3);
	doneList.remove(2);
	doneList.updateStorageVector(listOfTasks);
	EXPECT_EQ(2, listOfTasks.size());
	EXPECT_EQ(task1.getTask(), listOfTasks[0]);
	EXPECT_EQ(task3.getTask(), listOfTasks[1]);
}

//Check if the function removes a task properly according to the input task sting.
TEST(DoneLinkedListTest, RemoveFunctionByTask) {
	DoneLinkedList doneList;
	Date tempDate1(1,2,2013), tempDate2(3,4,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("dance lessons", "dance studio", tempDate1, 1500, tempDate2, 1800, nullDate, -1, false);
	Task task3("homework assignment 2", "", nullDate, -1, nullDate, -1, tempDate1, 2359, false);
	std::vector<std::string> listOfTasks;

	doneList.insert(task1);
	doneList.insert(task2);
	doneList.insert(task3);
	doneList.removeTask(task2.getTask());
	doneList.updateStorageVector(listOfTasks);
	EXPECT_EQ(2, listOfTasks.size());
	EXPECT_EQ(task1.getTask(), listOfTasks[0]);
	EXPECT_EQ(task3.getTask(), listOfTasks[1]);
}

/****************************
 TEST FOR UPDATE FUNCTION
****************************/

//Check if the function updates the linked list by removing overdued tasks.
TEST(DoneLinkedListTest, UpdateFunction) {
	DoneLinkedList doneList;
	Date tempDate1(1,2,2013), tempDate2(3,2,2013), nullDate, today(2,2,2013);
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("dance lessons", "dance studio", tempDate1, 1500, tempDate2, 1800, nullDate, -1, false);
	Task task3("homework assignment 2", "", nullDate, -1, nullDate, -1, tempDate1, 2359, false);
	std::vector<std::string> listOfTasks;

	doneList.insert(task1);
	doneList.insert(task2);
	doneList.insert(task3);
	doneList.update(today);
	doneList.updateStorageVector(listOfTasks);
	EXPECT_EQ(1, listOfTasks.size());
	EXPECT_EQ(task2.getTask(), listOfTasks[0]);
}
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\DoneLinkedListTest.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\DoneLinkedListTest.h
	 */

#include <gtest\gtest.h>
#include <DoneLinkedList.h>
#include <Date.h>
#include <Task.h>

class DoneLinkedListTest : public ::testing::Test {
protected:
	virtual void SetUp() {}

};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\DoneLinkedListTest.h





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\TaskLinkedListTest.cpp
	 */

#include <gtest\gtest.h>
#include "TaskLinkedListTest.h"

/****************************
 TEST FOR INSERT FUNCTION
****************************/

//Check to see if the function copies the date from one Date class to another Date class correctly.
TEST(TaskLinkedListTest, InsertMinorFunction1){
	TaskLinkedList taskList;
	Date inputDate(1, 2, 2013);
	Date date;

	taskList.obtainDateSeparately(&inputDate, &date);

	EXPECT_EQ(1, date._day);
	EXPECT_EQ(2, date._month);
	EXPECT_EQ(2013, date._year);
}

//Check to see if the function obtains the right date and time (either starting or deadline) and updates the ending date and time accordingly.
TEST(TaskLinkedListTest, InsertMinorFunction2){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), tempDate2(3,4,2013), tempDate3(5,6,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("lunch with mum", "techno", tempDate1, 1200, tempDate2, 1300, nullDate, -1, false);
	Task task3("lunch with mum", "techno", nullDate, -1, nullDate, -1, tempDate3, 1400, false);
	Date date, endDate;
	int time, endTime;


	taskList.obtainDateAndTime(task1, &date, &time, &endDate, &endTime);
	EXPECT_EQ(1, date._day);
	EXPECT_EQ(1200, time);
	EXPECT_EQ(0, endDate._day);
	EXPECT_EQ(-1, endTime);
	
	taskList.obtainDateAndTime(task3, &date, &time, &endDate, &endTime);
	EXPECT_EQ(5, date._day);
	EXPECT_EQ(1400, time);
	EXPECT_EQ(0, endDate._day);
	EXPECT_EQ(-1, endTime);

	taskList.obtainDateAndTime(task2, &date, &time, &endDate, &endTime);
	EXPECT_EQ(1, date._day);
	EXPECT_EQ(1200, time);
	EXPECT_EQ(3, endDate._day);
	EXPECT_EQ(1300, endTime);
}	

//Check to see if the comparing of 2 dates give the correct result (true if cur is earlier than list).
TEST(TaskLinkedListTest, InsertMinorFunction3){
	TaskLinkedList taskList;
	Date curDate(1,2,2013), listDate(3,4,2013);
	bool check = false;
	
	EXPECT_EQ(true, taskList.compareDates(&curDate, &listDate, &check));
	EXPECT_EQ(false, check);

	EXPECT_EQ(false, taskList.compareDates(&listDate, &curDate, &check));
	EXPECT_EQ(false, check);

	EXPECT_EQ(false, taskList.compareDates(&curDate, &curDate, &check));
	EXPECT_EQ(true, check);
}

//Check to see if the comaring of 2 tasks give the correct result (meaning which task should be sorted in front of which task accordingly to date and time).
TEST(TaskLinkedListTest, InsertMinorFunction4){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), tempDate2(3,4,2013), tempDate3(5,6,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("lunch with mum", "techno", tempDate2, 1200, tempDate2, 1300, nullDate, -1, false);
	Task task3("lunch with mum", "techno", nullDate, -1, nullDate, -1, tempDate3, 1400, false);
	Task task4("lunch with mum", "techno", tempDate2, 1200, tempDate2, 1000, nullDate, -1, false);
	bool isClash = false;
	std::vector<std::string> clashTasks;

	EXPECT_EQ(true, taskList.compareDateAndTime(task1, task2, isClash, clashTasks));
	EXPECT_EQ(false, taskList.compareDateAndTime(task2, task1, isClash, clashTasks));
	EXPECT_EQ(true, taskList.compareDateAndTime(task1, task3, isClash, clashTasks));
	EXPECT_EQ(false, taskList.compareDateAndTime(task2, task4, isClash, clashTasks));
}

//Check to see if function returns the correct index pointing to the task that is passed over.
TEST(TaskLinkedListTest, InsertMinorFunction5){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);	
	bool isClash = false;
	std::vector<std::string> clashTasks;

	EXPECT_EQ(1, taskList.getInsertIndex(task1, isClash, clashTasks));
}

//Check to see if the function inserts a task properly, sorted according to date and time.
TEST(TaskLinkedListTest, InsertFunction){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), tempDate2(3,4,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate2, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("dance lessons", "dance studio", tempDate1, 1500, tempDate1, 1800, nullDate, -1, false);
	Task task3("homework assignment 2", "", nullDate, -1, nullDate, -1, tempDate2, 2359, false);
	bool isClash = false;
	std::vector<std::string> clashTasks, listOfTasks;

	EXPECT_EQ(true, taskList.insert(task1, isClash, clashTasks));
	taskList.insert(task2, isClash, clashTasks);
	isClash = false;
	taskList.insert(task3, isClash, clashTasks);

	taskList.updateStorageVector(listOfTasks);
	EXPECT_EQ(task2.getTask(), listOfTasks[0]);
	EXPECT_EQ(task1.getTask(), listOfTasks[1]);
	EXPECT_EQ(task3.getTask(), listOfTasks[2]);
}

//Check to see if function is able to detect clashes in time properly or not.
TEST(TaskLinkedListTest, CheckForClashesInInsert){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("dance lessons", "dance studio", tempDate1, 1000, tempDate1, 1400, nullDate, -1, false);
	Task task3("homework assignment 2", "", nullDate, -1, nullDate, -1, tempDate1, 1200, false);
	Task task4("meeting friends", "marina square", tempDate1, 1700, nullDate, -1, nullDate, -1, false);
	bool isClash = false;
	std::vector<std::string> clashTasks;

	taskList.insert(task1, isClash, clashTasks);
	EXPECT_EQ(false, isClash);
	EXPECT_EQ(0, clashTasks.size());
	
	isClash = false;
	clashTasks.clear();
	taskList.insert(task2, isClash, clashTasks);
	EXPECT_EQ(true, isClash);
	EXPECT_EQ(task1.getTask(), clashTasks[0]);
	EXPECT_EQ(1, clashTasks.size());

	isClash = false;
	clashTasks.clear();
	taskList.insert(task4, isClash, clashTasks);
	EXPECT_EQ(false, isClash);
	EXPECT_EQ(0, clashTasks.size());

	isClash = false;
	clashTasks.clear();
	taskList.insert(task3, isClash, clashTasks);
	EXPECT_EQ(true, isClash);
	EXPECT_EQ(task2.getTask(), clashTasks[0]);
	EXPECT_EQ(task1.getTask(), clashTasks[1]);
	EXPECT_EQ(2, clashTasks.size());
}

/****************************
 TEST FOR REMOVE FUNCTION
****************************/

//Check to see if the function returns the correct index for the task to be removed.
TEST(TaskLinkedListTest, RemoveMinorFunction1){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("dance lessons", "dance studio", tempDate1, 1000, tempDate1, 1400, nullDate, -1, false);
	Task task3("homework assignment 2", "", nullDate, -1, nullDate, -1, tempDate1, 1200, false);
	bool isClash = false;
	std::vector<std::string> clashTasks;
	int index = 1;

	taskList.insert(task1, isClash, clashTasks);
	taskList.insert(task2, isClash, clashTasks);
	isClash = false;
	taskList.insert(task3, isClash, clashTasks);
	EXPECT_EQ(true, taskList.getRemoveIndex(task3.getTask(), &index));
	EXPECT_EQ(3, index);
}

//Check the function if it splits a sentence into a vector of keywords properly.
TEST(TaskLinkedListTest, RemoveMinorFunction2){
	TaskLinkedList taskList;
	std::vector<std::string> keywords;
	
	taskList.splitIntoKeywords("lunch with mum", keywords);
	EXPECT_EQ("lunch", keywords[0]);
	EXPECT_EQ("with", keywords[1]);
	EXPECT_EQ("mum", keywords[2]);
	EXPECT_EQ(3, keywords.size());
}

//Check to see if the function unblocks a task when the task is found to be the last remaining blockoff one.
TEST(TaskLinkedListTest, CheckLastBlockOffInRemove){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, true);
	Task task2("lunch with mum", "techno", tempDate1, 1400, nullDate, -1, nullDate, -1, true);
	Task task3("dance lessons", "dance studio", tempDate1, 1700, nullDate, -1, nullDate, -1, true);
	bool isClash = false;
	std::vector<std::string> clashTasks;

	taskList.insert(task1, isClash, clashTasks);
	taskList.insert(task2, isClash, clashTasks);
	taskList.insert(task3, isClash, clashTasks);

	taskList.checkIfRemainingBlockTask("dance lesson at dance studio");
	EXPECT_EQ(false, taskList.getBlockStatus(3));

	taskList.checkIfRemainingBlockTask("lunch with mum at techno");
	EXPECT_EQ(true, taskList.getBlockStatus(1));
	EXPECT_EQ(true, taskList.getBlockStatus(2));
}
	
//Check to see if the function removes a task from the linked list properly.
TEST(TaskLinkedListTest, RemoveFunction){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("lunch with mum", "techno", tempDate1, 1400, nullDate, -1, nullDate, -1, false);
	Task task3("dance lessons", "dance studio", tempDate1, 1700, nullDate, -1, nullDate, -1, false);
	bool isClash = false;
	std::vector<std::string> clashTasks, listOfTasks;

	taskList.insert(task1, isClash, clashTasks);
	taskList.insert(task2, isClash, clashTasks);
	taskList.insert(task3, isClash, clashTasks);

	EXPECT_EQ(true, taskList.remove(task1.getTask(), "lunch with mum at techno"));
	taskList.updateStorageVector(listOfTasks);
	EXPECT_EQ(task2.getTask(), listOfTasks[0]);
	EXPECT_EQ(task3.getTask(), listOfTasks[1]);
	EXPECT_EQ(2, listOfTasks.size());
}

/****************************
 TEST FOR RETRIEVE FUNCTION
****************************/

//Check to see if the function converts the line to lowercase.
TEST(TaskLinkedListTest, RetrieveMinorFunction1){
	TaskLinkedList taskList;
	EXPECT_EQ("abcdef", taskList.toLowerCase("AbCDeF"));
}

//Check to see if the function strings up the integers into a string date in the dd/mm/yyyy format.
TEST(TaskLinkedListTest, RetrieveMinorFunction2){
	TaskLinkedList taskList;
	EXPECT_EQ("01/02/2013", taskList.getStringDate(1,2,2013));
	EXPECT_EQ("10/12/2013", taskList.getStringDate(10,12,2013));
}

//Check to see if the function pushes in the range of dates correctly.
TEST(TaskLinkedListTest, RetrieveMinorFunction3){
	TaskLinkedList taskList;
	Date tempDate1(31,12,2013), tempDate2(1,2,2014), nullDate;
	Task task1("lunch with mum", "techno", tempDate1, 1200, tempDate2, 1500, nullDate, -1, false);
	EXPECT_EQ(task1.getTask() + "31/12/201301/01/201401/02/2014", taskList.compareAndIncludeRange(task1.getTask(), &tempDate1._day, &tempDate1._month, &tempDate1._year, &tempDate2._day, &tempDate2._month, &tempDate2._year));
}

//Check to see if the function is able to retrieve tasks that contains the keywords.
TEST(TaskLinkedListTest, RetrieveFunction){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), tempDate2(3,2,2013), nullDate;
	Task task1("lunch with mum", "deck", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("lunch with mum", "techno", tempDate1, 1400, tempDate2, 1000, nullDate, -1, false);
	Task task3("lunch with dad", "YIH", nullDate, -1, nullDate, -1, tempDate2, 1800, false);
	bool isClash = false;
	std::vector<std::string> clashTasks, keywords, retrieveTasks;

	taskList.insert(task1, isClash, clashTasks);
	taskList.insert(task2, isClash, clashTasks);
	taskList.insert(task3, isClash, clashTasks);

	keywords.push_back("lunch");
	keywords.push_back("with");
	keywords.push_back("mum");
	EXPECT_EQ(true, taskList.retrieve(keywords, retrieveTasks));
	EXPECT_EQ(task1.getTask(), retrieveTasks[0]);
	EXPECT_EQ(task2.getTask(), retrieveTasks[1]);
	EXPECT_EQ(2, retrieveTasks.size());

	keywords.clear();
	retrieveTasks.clear();
	keywords.push_back("02/02/2013");
	EXPECT_EQ(true, taskList.retrieve(keywords, retrieveTasks));
	EXPECT_EQ(task2.getTask(), retrieveTasks[0]);
	EXPECT_EQ(1, retrieveTasks.size());

	retrieveTasks.clear();
	keywords.push_back("dad");
	EXPECT_EQ(false, taskList.retrieve(keywords, retrieveTasks));
}

/****************************************
 TEST FOR UPDATING OVERDUELIST FUNCTION
*****************************************/

//Check to see if the function compares the date properly and push those task that are overdued into a vector.
TEST(TaskLinkedListTest, UpdateMinorFunction1){
	TaskLinkedList taskList;
	Date today(10,11,2013), beforeDate(9,11,2013), afterDate(11,11,2013);
	std::vector<std::string> overdueList;
	std::string task1 = "lunch with mum", task2 = "lunch with dad", task3 = "lunch with sis";

	taskList.compareWithToday(today, today, task1, overdueList);
	EXPECT_EQ(0, overdueList.size());
	taskList.compareWithToday(today, beforeDate, task2, overdueList);
	EXPECT_EQ(task2, overdueList[0]);
	EXPECT_EQ(1, overdueList.size());
	taskList.compareWithToday(today, afterDate, task3, overdueList);
	EXPECT_EQ(task2, overdueList[0]);
	EXPECT_EQ(1, overdueList.size());
}

//Check to see if the function is able to update properly by removing overdued items.
TEST(TaskLinkedListTest, UpdateFunction){
	TaskLinkedList taskList;
	Date tempDate1(1,2,2013), tempDate2(3,2,2013), nullDate, today(2,2,2013);
	Task task1("lunch with mum", "deck", tempDate1, 1200, nullDate, -1, nullDate, -1, false);
	Task task2("lunch with mum", "techno", tempDate1, 1400, tempDate2, 1000, nullDate, -1, false);
	Task task3("lunch with dad", "YIH", nullDate, -1, nullDate, -1, tempDate2, 1800, false);
	bool isClash = false;
	std::vector<std::string> clashTasks, overdueList;

	taskList.insert(task1, isClash, clashTasks);
	taskList.insert(task2, isClash, clashTasks);
	taskList.insert(task3, isClash, clashTasks);

	taskList.getOverdueList(today, overdueList);
	EXPECT_EQ(1, overdueList.size());
	EXPECT_EQ(task1.getTask(), overdueList[0]);
}
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\TaskLinkedListTest.cpp





	/**
	 * origin: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\TaskLinkedListTest.h
	 */

#include <gtest\gtest.h>
#include <TaskLinkedList.h>
#include <Date.h>
#include <Task.h>

class TaskLinkedListTest : public ::testing::Test {
protected:
	virtual void SetUp() {}

};
	// End of segment: C:\Users\Weiyuan\Desktop\CS2103 Project Remote\unit_test\TaskLinkedListTest.h





